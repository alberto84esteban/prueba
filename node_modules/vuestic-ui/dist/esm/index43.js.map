{"version":3,"file":"index43.js","sources":["../../src/composables/useMaxSelections.ts","../../src/components/va-select/VaSelectOptionList/VaSelectOptionList.vue","../../src/utils/scroll-to-element.ts","../../src/components/va-select/VaSelectOptionList/VaSelectOptionList.vue?vue&type=template&id=59030744&lang.js","../../src/components/va-select/VaSelectOptionList/index.ts","../../src/components/va-select/VaSelect.vue","../../src/components/va-select/VaSelect.vue?vue&type=template&id=ef3afb70&lang.js","../../src/components/va-select/index.ts"],"sourcesContent":["import { PropType, Ref } from 'vue'\n\n/**\n * You could add these props to any component by destructuring them inside props option.\n * @example\n * props: { ...useMaxSelectionsProps, componentsOwnProp, etc. }\n * It's better to add props at the beginning, to make sure that Component own props will be used instead in case of collision\n */\nexport const useMaxSelectionsProps = {\n  maxSelections: {\n    type: [Number, String] as PropType<number | string>,\n    default: undefined,\n  },\n}\n\nexport function useMaxSelections (\n  selections: Ref<any[]>,\n  maxSelections: Ref<number | string | undefined>,\n  emit: (event: 'update:modelValue', ...args: any[]) => void,\n) {\n  const exceedsMaxSelections = (): boolean => {\n    if (maxSelections.value === undefined || isNaN(+maxSelections.value)) { return false }\n    return selections.value.length >= maxSelections.value\n  }\n\n  const addOption = (optionToAdd: any): void => {\n    const newSelectedOptions = [...selections.value, optionToAdd]\n    emit('update:modelValue', newSelectedOptions)\n  }\n\n  return {\n    exceedsMaxSelections,\n    addOption,\n  }\n}\n","<template>\n  <div\n    class=\"va-select-option-list\"\n    ref=\"rootElement\"\n    :tabindex=\"tabindex\"\n    @keydown.up.stop.prevent=\"hoverPreviousOption\"\n    @keydown.left.stop.prevent=\"hoverPreviousOption\"\n    @keydown.down.stop.prevent=\"hoverNextOption\"\n    @keydown.right.stop.prevent=\"hoverNextOption\"\n    @scroll.passive=\"onScroll\"\n  >\n    <template\n      v-for=\"(options, groupName) in optionGroups\"\n      :key=\"groupName\"\n    >\n      <span\n        v-if=\"groupName !== '_noGroup'\"\n        class=\"va-select-option-list__group-name\"\n      >\n        {{ groupName }}\n      </span>\n      <div\n        v-for=\"option in options\"\n        :key=\"$props.getTrackBy(option)\"\n        :ref=\"setItemRef(option)\"\n        :class=\"getOptionClass(option)\"\n        :style=\"getOptionStyle(option)\"\n        @click.stop=\"selectOption(option)\"\n        @mouseover=\"updateHoveredOption(option)\"\n      >\n        <va-icon\n          v-if=\"getOptionIcon(option)\"\n          size=\"small\"\n          class=\"va-select-option-list__option--icon\"\n          :name=\"getOptionIcon(option)\"\n        />\n        <span>{{ getText(option) }}</span>\n        <va-icon\n          v-show=\"$props.getSelectedState(option)\"\n          class=\"va-select-option-list__option--selected-icon\"\n          size=\"small\"\n          name=\"done\"\n          :color=\"getColor($props.color)\"\n        />\n      </div>\n    </template>\n    <div\n      v-if=\"!filteredOptions.length\"\n      class=\"va-select-option-list no-options\"\n    >\n      {{ noOptionsText }}\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, watch, ref, Ref, computed } from 'vue'\n\nimport { getHoverColor } from '../../../services/color-config/color-functions'\nimport { useColors, useColorProps } from '../../../composables/useColor'\nimport { SelectableOption } from '../../..//composables/useSelectableList'\nimport VaIcon from '../../va-icon/'\nimport { scrollToElement } from '../../../utils/scroll-to-element'\n\nexport default defineComponent({\n  name: 'VaSelectOptionList',\n  components: { VaIcon },\n  emits: [\n    'select-option',\n    'update:hoveredOption',\n    'no-previous-option-to-hover',\n    'scroll-bottom',\n  ],\n  props: {\n    ...useColorProps,\n    options: { type: Array as PropType<SelectableOption[]>, default: () => [] },\n    noOptionsText: { type: String as PropType<string>, default: 'Items not found' },\n    getSelectedState: { type: Function as PropType<(option: SelectableOption) => boolean>, required: true },\n    getText: { type: Function as PropType<(option: SelectableOption) => string>, required: true },\n    getTrackBy: { type: Function as PropType<(option: SelectableOption) => number>, required: true },\n    getGroupBy: { type: Function as PropType<(option: SelectableOption) => string>, required: true },\n    multiple: { type: Boolean as PropType<boolean>, default: false },\n    search: { type: String as PropType<string>, default: '' },\n    tabindex: { type: Number as PropType<number>, default: 0 },\n    hoveredOption: {\n      type: [String, Number, Object] as PropType<SelectableOption | null>,\n      default: null,\n    },\n  },\n  setup (props, { emit }) {\n    const { getColor } = useColors()\n\n    const itemRefs: Ref<Record<number, HTMLElement>> = ref({})\n    const rootElement: Ref<HTMLElement | null> = ref(null)\n\n    const onScroll = ({ target }: { target: HTMLDivElement }) => {\n      if (target.scrollTop + target.clientHeight === target.scrollHeight) {\n        emit('scroll-bottom')\n      }\n    }\n\n    const beforeUpdate = () => { itemRefs.value = {} }\n\n    const setItemRef = (option: SelectableOption) => (el: HTMLElement) => {\n      if (el) {\n        itemRefs.value[props.getTrackBy(option)] = el\n      }\n    }\n\n    const hoveredOptionComputed = computed({\n      get: () => props.hoveredOption || null,\n      set: (value: SelectableOption | null) => emit('update:hoveredOption', value),\n    })\n\n    const filteredOptions = computed(() => {\n      if (!props.search) {\n        return props.options\n      }\n\n      return props.options.filter((option: SelectableOption) => {\n        const optionText = props.getText(option).toString().toUpperCase()\n        const search = props.search.toUpperCase()\n        return optionText.includes(search)\n      })\n    })\n\n    const optionGroups = computed(() => filteredOptions.value.reduce((groups: Record<string, SelectableOption[]>, option) => {\n      if (typeof option !== 'object' || !option.group) {\n        groups._noGroup.push(option)\n      } else {\n        const groupBy = props.getGroupBy(option)\n\n        if (!groups[groupBy]) { groups[groupBy] = [] }\n\n        groups[groupBy].push(option)\n      }\n\n      return groups\n    }, { _noGroup: [] }))\n\n    const selectOption = (option: SelectableOption) => emit('select-option', option)\n\n    const getOptionIcon = (option: SelectableOption) => typeof option === 'object' && option.icon\n\n    const getOptionClass = (option: SelectableOption) => ({\n      'va-select-option-list__option': true,\n      'va-select-option-list__option--selected': props.getSelectedState(option),\n    })\n\n    const getOptionStyle = (option: SelectableOption) => ({\n      color: props.getSelectedState(option) ? getColor(props.color) : 'inherit',\n      backgroundColor: isHovered(option) ? getHoverColor(getColor(props.color)) : 'transparent',\n    })\n\n    const isHovered = (option: SelectableOption) => {\n      if (!hoveredOptionComputed.value) { return false }\n      if (typeof option === 'string') { return option === hoveredOptionComputed.value }\n      if (!props.getTrackBy) { return false }\n\n      return props.getTrackBy(hoveredOptionComputed.value) === props.getTrackBy(option)\n    }\n\n    const updateHoveredOption = (option?: SelectableOption) => { hoveredOptionComputed.value = option || null }\n\n    const hoveredOptionIndex = computed(() => filteredOptions.value.findIndex((option) => {\n      return !!hoveredOptionComputed.value && props.getTrackBy(option) === props.getTrackBy(hoveredOptionComputed.value)\n    }))\n\n    const hoverPreviousOption = () => {\n      if (!hoveredOptionComputed.value) {\n        // Hover last option from list\n        filteredOptions.value.length && updateHoveredOption(filteredOptions.value.at(-1))\n      } else {\n        if (filteredOptions.value[hoveredOptionIndex.value - 1]) {\n          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value - 1]\n        } else {\n          emit('no-previous-option-to-hover')\n        }\n      }\n    }\n\n    const hoverNextOption = () => {\n      if (!hoveredOptionComputed.value) {\n        // Hover first option from list\n        filteredOptions.value.length && updateHoveredOption(filteredOptions.value[0])\n      } else {\n        if (filteredOptions.value[hoveredOptionIndex.value + 1]) {\n          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value + 1]\n        }\n      }\n    }\n\n    const hoverFirstOption = () => {\n      if (filteredOptions.value.length > 0) {\n        updateHoveredOption(filteredOptions.value[0])\n      }\n    }\n\n    const focus = () => {\n      // Prevent scroll since element in dropdown and it cause scrolling to page end.\n      rootElement.value?.focus({ preventScroll: true })\n    }\n\n    const scrollToOption = (option: SelectableOption) => {\n      if (!option) { return }\n\n      const element = itemRefs.value[props.getTrackBy(option)]\n\n      if (element) {\n        scrollToElement(element)\n      }\n    }\n\n    watch(() => props.hoveredOption, (newOption: SelectableOption | null) => newOption && scrollToOption(newOption))\n\n    const publicMethods = {\n      hoverPreviousOption,\n      hoverNextOption,\n      hoverFirstOption,\n      focus,\n    }\n\n    return {\n      getColor,\n      filteredOptions,\n      optionGroups,\n      onScroll,\n      beforeUpdate,\n      setItemRef,\n      selectOption,\n      getOptionIcon,\n      getOptionClass,\n      getOptionStyle,\n      updateHoveredOption,\n      ...publicMethods,\n    }\n  },\n\n  // we will use this while we have 'withConfigTransport'\n  methods: {\n    hoverPreviousOption () { (this as any).rootElement?.hoverPreviousOption() },\n    hoverNextOption () { (this as any).rootElement?.hoverNextOption() },\n    hoverFirstOption () { (this as any).rootElement?.hoverFirstOption() },\n    focus () { (this as any).rootElement?.focus() },\n    scrollToOption () { (this as any).rootElement?.scrollToOption() },\n\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../../styles/resources\";\n@import \"variables\";\n\n.va-select-option-list {\n  display: var(--va-select-option-list-display);\n  flex-direction: var(--va-select-option-list-flex-direction);\n  width: var(--va-select-option-list-width);\n  list-style: var(--va-select-option-list-list-style);\n  max-height: var(--va-select-option-list-max-height);\n  font-family: var(--va-font-family);\n  overflow: auto;\n\n  @include va-scroll();\n\n  &__group-name {\n    padding: var(--va-select-option-list-group-name-padding);\n    font-size: var(--va-select-option-list-group-name-font-size);\n    color: var(--va-select-option-list-group-name-color);\n    font-weight: var(--va-select-option-list-group-name-font-weight);\n    text-transform: uppercase;\n  }\n\n  &__option {\n    cursor: var(--va-select-option-list-option-cursor);\n    display: var(--va-select-option-list-option-display);\n    align-items: var(--va-select-option-list-option-align-items);\n    padding: var(--va-select-option-list-option-padding);\n    min-height: var(--va-select-option-list-option-min-height);\n    word-break: var(--va-select-option-list-option-word-break);\n\n    &--icon {\n      margin-right: var(--va-select-option-list-icon-margin-right);\n    }\n\n    &--selected-icon {\n      margin-left: var(--va-select-option-list-selected-icon-margin-left);\n      font-size: var(--va-select-option-list-selected-icon-font-size);\n    }\n  }\n\n  &.no-options {\n    padding: 0.5rem;\n  }\n}\n</style>\n","const getTopCoordinate = (element: HTMLElement) => element.offsetTop\nconst getBottomCoordinate = (element: HTMLElement) => element.offsetTop + element.offsetHeight\nconst getCenterCoordinate = (element: HTMLElement) => element.offsetTop + element.offsetHeight / 2\n\nconst getScrollTop = (element: HTMLElement, scrollTarget: HTMLElement, verticalAlignment?: 'start' | 'end' | 'center' | 'any') => {\n  const viewHeight = scrollTarget.offsetHeight\n  const currentPosition = scrollTarget.scrollTop\n  const top = getTopCoordinate(element) - scrollTarget.offsetTop\n  const center = getCenterCoordinate(element) - scrollTarget.offsetTop\n  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop\n\n  if (verticalAlignment === 'start') {\n    return top\n  }\n\n  if (verticalAlignment === 'end') {\n    return bottom - viewHeight\n  }\n\n  if (verticalAlignment === 'center') {\n    return center - viewHeight / 2\n  }\n\n  if (verticalAlignment === 'any') {\n    if (top - currentPosition < 0) {\n      return top\n    }\n\n    if (bottom - currentPosition > viewHeight) {\n      return bottom - viewHeight\n    }\n  }\n}\n\n/**\n * @param options.scrollTarget - element that will be scrolled\n */\nexport const scrollToElement = (element: HTMLElement, options: {\n  scrollTarget?: HTMLElement,\n  verticalAlignment?: 'start' | 'end' | 'center' | 'any',\n  smooth?: boolean,\n} = {\n  scrollTarget: element.parentElement!,\n  verticalAlignment: 'any',\n  smooth: false,\n}) => {\n  const scrollTarget = options.scrollTarget || element.parentElement!\n\n  const top = getScrollTop(element, scrollTarget, options.verticalAlignment)\n\n  if (top === undefined) { return }\n\n  scrollTarget.scroll({\n    top: top,\n    behavior: options.smooth ? 'smooth' : 'auto',\n  })\n}\n","<template>\n  <div\n    class=\"va-select-option-list\"\n    ref=\"rootElement\"\n    :tabindex=\"tabindex\"\n    @keydown.up.stop.prevent=\"hoverPreviousOption\"\n    @keydown.left.stop.prevent=\"hoverPreviousOption\"\n    @keydown.down.stop.prevent=\"hoverNextOption\"\n    @keydown.right.stop.prevent=\"hoverNextOption\"\n    @scroll.passive=\"onScroll\"\n  >\n    <template\n      v-for=\"(options, groupName) in optionGroups\"\n      :key=\"groupName\"\n    >\n      <span\n        v-if=\"groupName !== '_noGroup'\"\n        class=\"va-select-option-list__group-name\"\n      >\n        {{ groupName }}\n      </span>\n      <div\n        v-for=\"option in options\"\n        :key=\"$props.getTrackBy(option)\"\n        :ref=\"setItemRef(option)\"\n        :class=\"getOptionClass(option)\"\n        :style=\"getOptionStyle(option)\"\n        @click.stop=\"selectOption(option)\"\n        @mouseover=\"updateHoveredOption(option)\"\n      >\n        <va-icon\n          v-if=\"getOptionIcon(option)\"\n          size=\"small\"\n          class=\"va-select-option-list__option--icon\"\n          :name=\"getOptionIcon(option)\"\n        />\n        <span>{{ getText(option) }}</span>\n        <va-icon\n          v-show=\"$props.getSelectedState(option)\"\n          class=\"va-select-option-list__option--selected-icon\"\n          size=\"small\"\n          name=\"done\"\n          :color=\"getColor($props.color)\"\n        />\n      </div>\n    </template>\n    <div\n      v-if=\"!filteredOptions.length\"\n      class=\"va-select-option-list no-options\"\n    >\n      {{ noOptionsText }}\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, watch, ref, Ref, computed } from 'vue'\n\nimport { getHoverColor } from '../../../services/color-config/color-functions'\nimport { useColors, useColorProps } from '../../../composables/useColor'\nimport { SelectableOption } from '../../..//composables/useSelectableList'\nimport VaIcon from '../../va-icon/'\nimport { scrollToElement } from '../../../utils/scroll-to-element'\n\nexport default defineComponent({\n  name: 'VaSelectOptionList',\n  components: { VaIcon },\n  emits: [\n    'select-option',\n    'update:hoveredOption',\n    'no-previous-option-to-hover',\n    'scroll-bottom',\n  ],\n  props: {\n    ...useColorProps,\n    options: { type: Array as PropType<SelectableOption[]>, default: () => [] },\n    noOptionsText: { type: String as PropType<string>, default: 'Items not found' },\n    getSelectedState: { type: Function as PropType<(option: SelectableOption) => boolean>, required: true },\n    getText: { type: Function as PropType<(option: SelectableOption) => string>, required: true },\n    getTrackBy: { type: Function as PropType<(option: SelectableOption) => number>, required: true },\n    getGroupBy: { type: Function as PropType<(option: SelectableOption) => string>, required: true },\n    multiple: { type: Boolean as PropType<boolean>, default: false },\n    search: { type: String as PropType<string>, default: '' },\n    tabindex: { type: Number as PropType<number>, default: 0 },\n    hoveredOption: {\n      type: [String, Number, Object] as PropType<SelectableOption | null>,\n      default: null,\n    },\n  },\n  setup (props, { emit }) {\n    const { getColor } = useColors()\n\n    const itemRefs: Ref<Record<number, HTMLElement>> = ref({})\n    const rootElement: Ref<HTMLElement | null> = ref(null)\n\n    const onScroll = ({ target }: { target: HTMLDivElement }) => {\n      if (target.scrollTop + target.clientHeight === target.scrollHeight) {\n        emit('scroll-bottom')\n      }\n    }\n\n    const beforeUpdate = () => { itemRefs.value = {} }\n\n    const setItemRef = (option: SelectableOption) => (el: HTMLElement) => {\n      if (el) {\n        itemRefs.value[props.getTrackBy(option)] = el\n      }\n    }\n\n    const hoveredOptionComputed = computed({\n      get: () => props.hoveredOption || null,\n      set: (value: SelectableOption | null) => emit('update:hoveredOption', value),\n    })\n\n    const filteredOptions = computed(() => {\n      if (!props.search) {\n        return props.options\n      }\n\n      return props.options.filter((option: SelectableOption) => {\n        const optionText = props.getText(option).toString().toUpperCase()\n        const search = props.search.toUpperCase()\n        return optionText.includes(search)\n      })\n    })\n\n    const optionGroups = computed(() => filteredOptions.value.reduce((groups: Record<string, SelectableOption[]>, option) => {\n      if (typeof option !== 'object' || !option.group) {\n        groups._noGroup.push(option)\n      } else {\n        const groupBy = props.getGroupBy(option)\n\n        if (!groups[groupBy]) { groups[groupBy] = [] }\n\n        groups[groupBy].push(option)\n      }\n\n      return groups\n    }, { _noGroup: [] }))\n\n    const selectOption = (option: SelectableOption) => emit('select-option', option)\n\n    const getOptionIcon = (option: SelectableOption) => typeof option === 'object' && option.icon\n\n    const getOptionClass = (option: SelectableOption) => ({\n      'va-select-option-list__option': true,\n      'va-select-option-list__option--selected': props.getSelectedState(option),\n    })\n\n    const getOptionStyle = (option: SelectableOption) => ({\n      color: props.getSelectedState(option) ? getColor(props.color) : 'inherit',\n      backgroundColor: isHovered(option) ? getHoverColor(getColor(props.color)) : 'transparent',\n    })\n\n    const isHovered = (option: SelectableOption) => {\n      if (!hoveredOptionComputed.value) { return false }\n      if (typeof option === 'string') { return option === hoveredOptionComputed.value }\n      if (!props.getTrackBy) { return false }\n\n      return props.getTrackBy(hoveredOptionComputed.value) === props.getTrackBy(option)\n    }\n\n    const updateHoveredOption = (option?: SelectableOption) => { hoveredOptionComputed.value = option || null }\n\n    const hoveredOptionIndex = computed(() => filteredOptions.value.findIndex((option) => {\n      return !!hoveredOptionComputed.value && props.getTrackBy(option) === props.getTrackBy(hoveredOptionComputed.value)\n    }))\n\n    const hoverPreviousOption = () => {\n      if (!hoveredOptionComputed.value) {\n        // Hover last option from list\n        filteredOptions.value.length && updateHoveredOption(filteredOptions.value.at(-1))\n      } else {\n        if (filteredOptions.value[hoveredOptionIndex.value - 1]) {\n          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value - 1]\n        } else {\n          emit('no-previous-option-to-hover')\n        }\n      }\n    }\n\n    const hoverNextOption = () => {\n      if (!hoveredOptionComputed.value) {\n        // Hover first option from list\n        filteredOptions.value.length && updateHoveredOption(filteredOptions.value[0])\n      } else {\n        if (filteredOptions.value[hoveredOptionIndex.value + 1]) {\n          hoveredOptionComputed.value = filteredOptions.value[hoveredOptionIndex.value + 1]\n        }\n      }\n    }\n\n    const hoverFirstOption = () => {\n      if (filteredOptions.value.length > 0) {\n        updateHoveredOption(filteredOptions.value[0])\n      }\n    }\n\n    const focus = () => {\n      // Prevent scroll since element in dropdown and it cause scrolling to page end.\n      rootElement.value?.focus({ preventScroll: true })\n    }\n\n    const scrollToOption = (option: SelectableOption) => {\n      if (!option) { return }\n\n      const element = itemRefs.value[props.getTrackBy(option)]\n\n      if (element) {\n        scrollToElement(element)\n      }\n    }\n\n    watch(() => props.hoveredOption, (newOption: SelectableOption | null) => newOption && scrollToOption(newOption))\n\n    const publicMethods = {\n      hoverPreviousOption,\n      hoverNextOption,\n      hoverFirstOption,\n      focus,\n    }\n\n    return {\n      getColor,\n      filteredOptions,\n      optionGroups,\n      onScroll,\n      beforeUpdate,\n      setItemRef,\n      selectOption,\n      getOptionIcon,\n      getOptionClass,\n      getOptionStyle,\n      updateHoveredOption,\n      ...publicMethods,\n    }\n  },\n\n  // we will use this while we have 'withConfigTransport'\n  methods: {\n    hoverPreviousOption () { (this as any).rootElement?.hoverPreviousOption() },\n    hoverNextOption () { (this as any).rootElement?.hoverNextOption() },\n    hoverFirstOption () { (this as any).rootElement?.hoverFirstOption() },\n    focus () { (this as any).rootElement?.focus() },\n    scrollToOption () { (this as any).rootElement?.scrollToOption() },\n\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../../styles/resources\";\n@import \"variables\";\n\n.va-select-option-list {\n  display: var(--va-select-option-list-display);\n  flex-direction: var(--va-select-option-list-flex-direction);\n  width: var(--va-select-option-list-width);\n  list-style: var(--va-select-option-list-list-style);\n  max-height: var(--va-select-option-list-max-height);\n  font-family: var(--va-font-family);\n  overflow: auto;\n\n  @include va-scroll();\n\n  &__group-name {\n    padding: var(--va-select-option-list-group-name-padding);\n    font-size: var(--va-select-option-list-group-name-font-size);\n    color: var(--va-select-option-list-group-name-color);\n    font-weight: var(--va-select-option-list-group-name-font-weight);\n    text-transform: uppercase;\n  }\n\n  &__option {\n    cursor: var(--va-select-option-list-option-cursor);\n    display: var(--va-select-option-list-option-display);\n    align-items: var(--va-select-option-list-option-align-items);\n    padding: var(--va-select-option-list-option-padding);\n    min-height: var(--va-select-option-list-option-min-height);\n    word-break: var(--va-select-option-list-option-word-break);\n\n    &--icon {\n      margin-right: var(--va-select-option-list-icon-margin-right);\n    }\n\n    &--selected-icon {\n      margin-left: var(--va-select-option-list-selected-icon-margin-left);\n      font-size: var(--va-select-option-list-selected-icon-font-size);\n    }\n  }\n\n  &.no-options {\n    padding: 0.5rem;\n  }\n}\n</style>\n","import withConfigTransport from '../../../services/config-transport/withConfigTransport'\nimport VaSelectOptionList from './VaSelectOptionList.vue'\n\nexport default withConfigTransport(VaSelectOptionList)\n","<template>\n  <va-dropdown\n    ref=\"dropdown\"\n    class=\"va-select__dropdown va-select-dropdown\"\n    trigger=\"none\"\n    anchorSelector=\".va-input-wrapper__input\"\n    :position=\"$props.position\"\n    :disabled=\"$props.disabled\"\n    :max-height=\"$props.maxHeight\"\n    :fixed=\"$props.fixed\"\n    :close-on-content-click=\"closeOnContentClick\"\n    :stateful=\"false\"\n    :offset=\"[0, 1]\"\n    keep-anchor-width\n    v-model=\"showDropdownContentComputed\"\n    @keydown.up.stop.prevent=\"showDropdown()\"\n    @keydown.down.stop.prevent=\"showDropdown()\"\n    @keydown.space.stop.prevent=\"showDropdown()\"\n    @click.prevent=\"onSelectClick()\"\n  >\n    <template #anchor>\n      <div class=\"va-select\">\n        <va-input\n          ref=\"input\"\n          :model-value=\"valueComputedString\"\n          :success=\"$props.success\"\n          :error=\"computedError\"\n          :color=\"$props.color\"\n          :label=\"$props.label\"\n          :placeholder=\"$props.placeholder\"\n          :loading=\"$props.loading\"\n          :disabled=\"$props.disabled\"\n          :outline=\"$props.outline\"\n          :bordered=\"$props.bordered\"\n          :required-mark=\"$props.requiredMark\"\n          :tabindex=\"tabIndexComputed\"\n          :messages=\"$props.messages\"\n          :error-messages=\"computedErrorMessages\"\n          readonly\n          @focus=\"onInputFocus()\"\n          @blur=\"onInputBlur()\"\n        >\n          <template\n            v-if=\"$slots.prepend\"\n            #prepend\n          >\n            <slot name=\"prepend\" />\n          </template>\n\n          <template\n            v-if=\"$slots.append\"\n            #append\n          >\n            <slot name=\"append\" />\n          </template>\n\n          <template\n            v-if=\"$slots.prependInner\"\n            #prependInner\n          >\n            <slot name=\"prependInner\" />\n          </template>\n\n          <template #icon>\n            <va-icon\n              v-if=\"showClearIcon\"\n              v-bind=\"clearIconProps\"\n              @click.stop=\"reset()\"\n            />\n          </template>\n\n          <template #appendInner>\n            <slot\n              v-if=\"$slots.appendInner\"\n              name=\"appendInner\"\n            />\n            <va-icon\n              :color=\"toggleIconColor\"\n              :name=\"toggleIcon\"\n            />\n          </template>\n\n          <template v-if=\"$slots.content\" #content>\n            <slot\n              name=\"content\"\n              v-bind=\"{ valueString: valueComputedString, value: valueComputed }\"\n            />\n          </template>\n        </va-input>\n      </div>\n    </template>\n\n    <!-- Stop propagation for enter keyup event, to prevent VaDropdown closing -->\n    <va-dropdown-content\n      class=\"va-select-dropdown__content\"\n      :style=\"{ width: $props.width }\"\n      @keyup.enter.stop\n      @keydown.tab.stop.prevent\n      @keydown.esc.prevent=\"hideDropdown()\"\n    >\n      <va-input\n        v-if=\"showSearchInput\"\n        ref=\"searchBar\"\n        class=\"va-select__input\"\n        placeholder=\"Search\"\n        :tabindex=\"tabindex + 1\"\n        :bordered=\"true\"\n        v-model=\"searchInput\"\n        @keydown.up.stop.prevent=\"hoverPreviousOption()\"\n        @keydown.left.stop.prevent=\"hoverPreviousOption()\"\n        @keydown.down.stop.prevent=\"hoverNextOption()\"\n        @keydown.right.stop.prevent=\"hoverNextOption()\"\n        @keydown.enter.prevent=\"selectOrAddOption()\"\n        @focus=\"hoveredOption = null\"\n      />\n      <div class=\"va-select-dropdown__options-wrapper\">\n        <va-select-option-list\n          ref=\"optionList\"\n          v-model:hoveredOption=\"hoveredOption\"\n          :style=\"{ maxHeight: $props.maxHeight }\"\n          :options=\"filteredOptions\"\n          :selected-value=\"valueComputed\"\n          :get-selected-state=\"checkIsOptionSelected\"\n          :get-text=\"getText\"\n          :get-track-by=\"getTrackBy\"\n          :get-group-by=\"getGroupBy\"\n          :search=\"searchInput\"\n          :no-options-text=\"$props.noOptionsText\"\n          :color=\"$props.color\"\n          :tabindex=\"tabindex + 1\"\n          @select-option=\"selectOption\"\n          @no-previous-option-to-hover=\"focusSearchBar()\"\n          @keydown.enter.stop.prevent=\"selectHoveredOption()\"\n          @keydown.space.stop.prevent=\"selectHoveredOption()\"\n          @keydown.tab.stop.prevent=\"searchBar && searchBar.focus()\"\n          @keydown=\"onHintedSearch\"\n          @scroll-bottom=\"onScrollBottom\"\n        />\n      </div>\n    </va-dropdown-content>\n  </va-dropdown>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, ref, computed, watch, nextTick } from 'vue'\n\nimport { useSelectableList, useSelectableListProps, SelectableOption } from '../../composables/useSelectableList'\nimport { useValidation, useValidationProps, useValidationEmits } from '../../composables/useValidation'\nimport { useFormProps } from '../../composables/useForm'\nimport { useLoadingProps } from '../../composables/useLoading'\nimport { useColor } from '../../composables/useColor'\nimport { useMaxSelections, useMaxSelectionsProps } from '../../composables/useMaxSelections'\nimport { useClearableProps, useClearable, useClearableEmits } from '../../composables/useClearable'\nimport { useColors } from '../../services/color-config/color-config'\nimport { warn } from '../../services/utils'\nimport VaDropdown, { VaDropdownContent } from '../va-dropdown'\nimport VaIcon from '../va-icon'\nimport VaInput from '../va-input'\nimport VaSelectOptionList from './VaSelectOptionList'\n\nconst { getHoverColor } = useColors()\n\ntype DropdownIcon = {\n  open: string,\n  close: string\n}\n\nexport default defineComponent({\n  name: 'VaSelect',\n\n  components: {\n    VaSelectOptionList,\n    VaIcon,\n    VaDropdown,\n    VaDropdownContent,\n    VaInput,\n  },\n\n  emits: [\n    'update:modelValue',\n    'update-search',\n    'create-new',\n    'scroll-bottom',\n    ...useValidationEmits,\n    ...useClearableEmits,\n  ],\n\n  props: {\n    ...useSelectableListProps,\n    ...useValidationProps,\n    ...useLoadingProps,\n    ...useMaxSelectionsProps,\n    ...useClearableProps,\n    ...useFormProps,\n\n    modelValue: {\n      type: [String, Number, Object] as PropType<SelectableOption>,\n      default: '',\n    },\n\n    // Dropdown position\n    position: {\n      type: String as PropType<string>,\n      default: 'bottom',\n      validator: (position: string) => ['top', 'bottom'].includes(position),\n    },\n\n    allowCreate: {\n      type: [Boolean, String] as PropType<boolean | string>,\n      default: false,\n      validator: (mode: string | boolean) => {\n        return [true, false, 'unique'].includes(mode)\n      },\n    },\n\n    color: { type: String as PropType<string>, default: 'primary' },\n    multiple: { type: Boolean as PropType<boolean>, default: false },\n    searchable: { type: Boolean as PropType<boolean>, default: false },\n    separator: { type: String as PropType<string>, default: ', ' },\n    width: { type: String as PropType<string>, default: '100%' },\n    maxHeight: { type: String as PropType<string>, default: '256px' },\n    noOptionsText: { type: String as PropType<string>, default: 'Items not found' },\n    fixed: { type: Boolean as PropType<boolean>, default: true },\n    hideSelected: { type: Boolean as PropType<boolean>, default: false },\n    tabindex: { type: Number as PropType<number>, default: 0 },\n    dropdownIcon: {\n      type: [String, Object] as PropType<string | DropdownIcon>,\n      default: (): DropdownIcon => ({\n        open: 'expand_more',\n        close: 'expand_less',\n      }),\n      validator: (value: any) => {\n        if (typeof value === 'string') { return true }\n\n        const isOpenIconString = typeof value.open === 'string'\n        const isCloseIconString = typeof value.close === 'string'\n\n        return isOpenIconString && isCloseIconString\n      },\n    },\n\n    // Input style\n    outline: { type: Boolean as PropType<boolean>, default: false },\n    bordered: { type: Boolean as PropType<boolean>, default: false },\n    label: { type: String as PropType<string>, default: '' },\n    placeholder: { type: String as PropType<string>, default: '' },\n    requiredMark: { type: Boolean as PropType<boolean>, default: false },\n  },\n\n  setup (props, { emit }) {\n    const optionList = ref<InstanceType<typeof VaSelectOptionList>>()\n    const input = ref<InstanceType<typeof VaInput>>()\n    const searchBar = ref<InstanceType<typeof VaInput>>()\n\n    const { getOptionByValue, getValue, getText, getTrackBy, getGroupBy } = useSelectableList(props)\n\n    const {\n      isFocused,\n      validate,\n      computedError,\n      computedErrorMessages,\n    } = useValidation(props, emit, () => reset(), () => focus())\n\n    const { colorComputed } = useColor(props)\n    const toggleIconColor = computed(() => (\n      props.readonly ? getHoverColor(colorComputed.value) : colorComputed.value\n    ))\n\n    const onScrollBottom = () => {\n      emit('scroll-bottom')\n    }\n\n    const searchInput = ref('')\n    const showSearchInput = computed(() => {\n      return props.searchable || props.allowCreate\n    })\n\n    watch(() => searchInput.value, (value) => {\n      emit('update-search', value)\n      hoveredOption.value = null\n    })\n\n    // Select value\n\n    const valueComputed = computed({\n      get () {\n        const value = getOptionByValue(props.modelValue)\n\n        if (props.multiple) {\n          if (!value) {\n            return []\n          }\n\n          if (!Array.isArray(value)) {\n            return [value]\n          }\n\n          return value\n        }\n\n        if (Array.isArray(value)) {\n          warn('Model value should be a string or a number for a single Select.')\n\n          if (value.length) {\n            return value[value.length - 1]\n          }\n        }\n\n        return value\n      },\n\n      set (value: any) {\n        emit('update:modelValue', getValue(value))\n      },\n    })\n\n    const valueComputedString = computed((): string | number => {\n      if (!valueComputed.value) { return props.clearValue }\n      if (typeof valueComputed.value === 'string' || typeof valueComputed.value === 'number') { return valueComputed.value }\n      if (Array.isArray(valueComputed.value)) {\n        return valueComputed.value.map((value) => getText(value)).join(props.separator) || props.clearValue\n      }\n\n      return getText(valueComputed.value)\n    })\n\n    // Icons\n    const {\n      canBeCleared,\n      clearIconProps,\n    } = useClearable(props, valueComputed, isFocused, computedError)\n\n    const showClearIcon = computed(() => {\n      if (props.multiple) { return !!valueComputed.value.length }\n      return canBeCleared.value\n    })\n\n    const toggleIcon = computed((): string => {\n      if (!props.dropdownIcon) { return '' }\n\n      if (typeof props.dropdownIcon === 'string') {\n        return props.dropdownIcon\n      }\n\n      return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open\n    })\n\n    // Options\n\n    const filteredOptions = computed((): any[] => {\n      if (!props.options) { return [] }\n\n      if (props.hideSelected) {\n        return (props.options).filter((option) => !checkIsOptionSelected(option))\n      }\n\n      return props.options\n    })\n\n    const checkIsOptionSelected = (option: any): boolean => {\n      if (!valueComputed.value) { return false }\n\n      if (Array.isArray(valueComputed.value)) {\n        return !!valueComputed.value.find((valueItem: any) => compareOptions(valueItem, option))\n      }\n\n      return compareOptions(valueComputed.value, option)\n    }\n\n    const compareOptions = (one: any, two: any) => {\n      // identity check works nice for strings and exact matches.\n      if (one === two) {\n        return true\n      }\n      if (typeof one === 'string' && typeof two === 'string') {\n        return one === two\n      }\n      if (one === null || two === null) {\n        return false\n      }\n      if (typeof one === 'object' && typeof two === 'object') {\n        return getTrackBy(one) === getTrackBy(two)\n      }\n\n      return false\n    }\n\n    const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections), emit)\n\n    const selectOption = (option: any): void => {\n      if (hoveredOption.value === null) {\n        hideDropdown()\n        return\n      }\n\n      if (showSearchInput.value) {\n        searchInput.value = ''\n      }\n\n      if (props.multiple) {\n        const isSelected = checkIsOptionSelected(option)\n\n        if (isSelected) {\n          // Unselect\n          valueComputed.value = valueComputed.value.filter((optionSelected: any) => !compareOptions(option, optionSelected))\n        } else {\n          if (exceedsMaxSelections()) { return }\n          addOption(option)\n        }\n      } else {\n        valueComputed.value = typeof option === 'string' || typeof option === 'number' ? option : { ...option }\n        hideDropdown()\n      }\n    }\n\n    const selectOrAddOption = () => {\n      if (hoveredOption.value !== null) {\n        selectHoveredOption()\n        return\n      }\n\n      if (allowedToCreate()) {\n        addNewOption()\n      }\n    }\n\n    const allowedToCreate = (): boolean => {\n      return !!(props.allowCreate && searchInput.value !== '')\n    }\n\n    const addNewOption = (): void => {\n      // Do not emit if option already exist and allow create is `unique`\n      const hasAddedOption: boolean = props.options?.some((option: any) => getText(option) === searchInput.value)\n\n      if (!(props.allowCreate === 'unique' && hasAddedOption)) {\n        emit('create-new', searchInput.value)\n        searchInput.value = ''\n      }\n    }\n\n    // Hovered options\n\n    const hoveredOption = ref(null as any)\n\n    const selectHoveredOption = () => {\n      if (!showDropdownContent.value) {\n        // We can not select options if they are hidden\n        showDropdown()\n        return\n      }\n\n      selectOption(hoveredOption.value)\n    }\n\n    const hoverPreviousOption = () => {\n      optionList.value?.hoverPreviousOption()\n    }\n\n    const hoverNextOption = () => {\n      optionList.value?.hoverNextOption()\n    }\n\n    // Dropdown content\n\n    const showDropdownContent = ref(false)\n\n    const showDropdownContentComputed = computed({\n      get: () => {\n        return showDropdownContent.value\n      },\n      set: (show: boolean) => {\n        show\n          ? showDropdown()\n          : hideDropdown()\n      },\n    })\n\n    const closeOnContentClick = computed(() => {\n      return !(props.multiple || props.searchable || props.allowCreate)\n    })\n\n    const showDropdown = () => {\n      if (props.disabled || props.readonly) { return }\n\n      showDropdownContent.value = true\n      scrollToSelected()\n      focusSearchOrOptions()\n    }\n\n    const hideDropdown = () => {\n      showDropdownContent.value = false\n      searchInput.value = ''\n      validate()\n      input.value?.focus()\n    }\n\n    const toggleDropdown = () => {\n      if (showDropdownContent.value) {\n        hideDropdown()\n      } else {\n        showDropdown()\n      }\n    }\n\n    const onSelectClick = () => {\n      if (props.disabled || props.readonly) { return }\n      toggleDropdown()\n    }\n\n    const focusSearchBar = () => {\n      searchBar.value?.focus()\n    }\n\n    const focusOptionList = () => {\n      optionList.value?.focus()\n      optionList.value?.hoverFirstOption()\n    }\n\n    const focusSearchOrOptions = () => {\n      nextTick(() => {\n        if (showSearchInput.value) {\n          focusSearchBar()\n        } else { focusOptionList() }\n      })\n    }\n\n    const onInputFocus = (): void => {\n      if (!isFocused.value) {\n        isFocused.value = true\n      }\n    }\n\n    const onInputBlur = (): void => {\n      if (!showDropdownContentComputed.value) {\n        isFocused.value\n          ? isFocused.value = false\n          : validate()\n      }\n    }\n\n    /** @public */\n    const focus = (): void => {\n      if (props.disabled) { return }\n      input.value?.focus()\n    }\n\n    /** @public */\n    const blur = (): void => {\n      if (showDropdownContentComputed.value) {\n        showDropdownContentComputed.value = false\n        nextTick(() => {\n          input.value?.blur()\n        })\n      } else {\n        input.value?.blur()\n      }\n    }\n\n    /** @public */\n    const reset = (): void => {\n      if (props.multiple) {\n        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : []\n      } else {\n        valueComputed.value = props.clearValue\n      }\n\n      searchInput.value = ''\n      emit('clear')\n    }\n\n    const tabIndexComputed = computed(() => {\n      return props.disabled ? -1 : props.tabindex\n    })\n\n    const scrollToSelected = (): void => {\n      const selected = valueComputed.value\n      const nothingSelected = !selected.length && typeof selected !== 'object'\n\n      if (nothingSelected) {\n        return\n      }\n\n      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected\n      hoveredOption.value = scrollTo\n      nextTick(() => optionList.value?.scrollToOption(scrollTo))\n    }\n\n    // Hinted search\n\n    let hintedSearchQuery = ''\n    let hintedSearchQueryTimeoutIndex!: any\n    const navigationKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', ' ']\n\n    // Hinted search - hover option if you typing it's value on select without search-bar\n    const onHintedSearch = (event: KeyboardEvent) => {\n      if (navigationKeys.some(key => key === event.key)) {\n        return\n      }\n\n      const isLetter: boolean = event.key.length === 1\n      const isDeleteKey: boolean = event.key === 'Backspace' || event.key === 'Delete'\n\n      clearTimeout(hintedSearchQueryTimeoutIndex)\n\n      if (isDeleteKey) {\n        // Remove last letter from query\n        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : ''\n      } else if (isLetter) {\n        // Add every new letter to the query\n        hintedSearchQuery += event.key\n      }\n\n      if (showSearchInput.value) {\n        searchInput.value = hintedSearchQuery\n        return\n      }\n\n      // Search for an option that matches the query\n      if (hintedSearchQuery) {\n        const appropriateOption = props.options.find(option => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()))\n        if (appropriateOption) {\n          hoveredOption.value = appropriateOption\n        }\n      }\n\n      hintedSearchQueryTimeoutIndex = setTimeout(() => { hintedSearchQuery = '' }, 1000)\n    }\n\n    return {\n      input,\n      optionList,\n      searchBar,\n\n      // while we have problem with 'withConfigTransport'\n      // focus,\n      // blur,\n\n      onInputFocus,\n      onInputBlur,\n      focusOptionList,\n      reset,\n      onSelectClick,\n      focusSearchBar,\n      searchInput,\n      showSearchInput,\n      hoveredOption,\n      tabIndexComputed,\n      valueComputed,\n      valueComputedString,\n      showClearIcon,\n      toggleIcon,\n      computedErrorMessages,\n      computedError,\n      filteredOptions,\n      checkIsOptionSelected,\n      closeOnContentClick,\n      selectOption,\n      selectOrAddOption,\n      selectHoveredOption,\n      hoverPreviousOption,\n      hoverNextOption,\n      showDropdownContentComputed,\n      showDropdown,\n      hideDropdown,\n      toggleDropdown,\n      toggleIconColor,\n      onHintedSearch,\n      getText,\n      getTrackBy,\n      getGroupBy,\n      onScrollBottom,\n      clearIconProps,\n    }\n  },\n  // we will use this while we have problem with 'withConfigTransport'\n  methods: {\n    focus () {\n      if (this.$props.disabled) { return }\n      this.input?.focus()\n    },\n    blur () {\n      if (this.showDropdownContentComputed) {\n        this.showDropdownContentComputed = false\n        nextTick(() => {\n          this.input?.blur()\n        })\n      } else {\n        this.input?.blur()\n      }\n    },\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-select {\n  cursor: var(--va-select-cursor);\n\n  .va-input {\n    cursor: var(--va-select-cursor);\n  }\n}\n\n.va-select-dropdown {\n  .va-dropdown__anchor {\n    display: block;\n  }\n\n  &__content {\n    overflow: hidden;\n    border-bottom-right-radius: var(--va-select-dropdown-border-radius);\n    border-bottom-left-radius: var(--va-select-dropdown-border-radius);\n    border-top-right-radius: 0;\n    border-top-left-radius: 0;\n    box-shadow: var(--va-select-box-shadow);\n    padding: 0;\n  }\n\n  &__options-wrapper {\n    background: var(--va-select-dropdown-background);\n    overflow-y: auto;\n\n    @include va-scroll(var(--va-select-scroll-color));\n  }\n}\n\n</style>\n","<template>\n  <va-dropdown\n    ref=\"dropdown\"\n    class=\"va-select__dropdown va-select-dropdown\"\n    trigger=\"none\"\n    anchorSelector=\".va-input-wrapper__input\"\n    :position=\"$props.position\"\n    :disabled=\"$props.disabled\"\n    :max-height=\"$props.maxHeight\"\n    :fixed=\"$props.fixed\"\n    :close-on-content-click=\"closeOnContentClick\"\n    :stateful=\"false\"\n    :offset=\"[0, 1]\"\n    keep-anchor-width\n    v-model=\"showDropdownContentComputed\"\n    @keydown.up.stop.prevent=\"showDropdown()\"\n    @keydown.down.stop.prevent=\"showDropdown()\"\n    @keydown.space.stop.prevent=\"showDropdown()\"\n    @click.prevent=\"onSelectClick()\"\n  >\n    <template #anchor>\n      <div class=\"va-select\">\n        <va-input\n          ref=\"input\"\n          :model-value=\"valueComputedString\"\n          :success=\"$props.success\"\n          :error=\"computedError\"\n          :color=\"$props.color\"\n          :label=\"$props.label\"\n          :placeholder=\"$props.placeholder\"\n          :loading=\"$props.loading\"\n          :disabled=\"$props.disabled\"\n          :outline=\"$props.outline\"\n          :bordered=\"$props.bordered\"\n          :required-mark=\"$props.requiredMark\"\n          :tabindex=\"tabIndexComputed\"\n          :messages=\"$props.messages\"\n          :error-messages=\"computedErrorMessages\"\n          readonly\n          @focus=\"onInputFocus()\"\n          @blur=\"onInputBlur()\"\n        >\n          <template\n            v-if=\"$slots.prepend\"\n            #prepend\n          >\n            <slot name=\"prepend\" />\n          </template>\n\n          <template\n            v-if=\"$slots.append\"\n            #append\n          >\n            <slot name=\"append\" />\n          </template>\n\n          <template\n            v-if=\"$slots.prependInner\"\n            #prependInner\n          >\n            <slot name=\"prependInner\" />\n          </template>\n\n          <template #icon>\n            <va-icon\n              v-if=\"showClearIcon\"\n              v-bind=\"clearIconProps\"\n              @click.stop=\"reset()\"\n            />\n          </template>\n\n          <template #appendInner>\n            <slot\n              v-if=\"$slots.appendInner\"\n              name=\"appendInner\"\n            />\n            <va-icon\n              :color=\"toggleIconColor\"\n              :name=\"toggleIcon\"\n            />\n          </template>\n\n          <template v-if=\"$slots.content\" #content>\n            <slot\n              name=\"content\"\n              v-bind=\"{ valueString: valueComputedString, value: valueComputed }\"\n            />\n          </template>\n        </va-input>\n      </div>\n    </template>\n\n    <!-- Stop propagation for enter keyup event, to prevent VaDropdown closing -->\n    <va-dropdown-content\n      class=\"va-select-dropdown__content\"\n      :style=\"{ width: $props.width }\"\n      @keyup.enter.stop\n      @keydown.tab.stop.prevent\n      @keydown.esc.prevent=\"hideDropdown()\"\n    >\n      <va-input\n        v-if=\"showSearchInput\"\n        ref=\"searchBar\"\n        class=\"va-select__input\"\n        placeholder=\"Search\"\n        :tabindex=\"tabindex + 1\"\n        :bordered=\"true\"\n        v-model=\"searchInput\"\n        @keydown.up.stop.prevent=\"hoverPreviousOption()\"\n        @keydown.left.stop.prevent=\"hoverPreviousOption()\"\n        @keydown.down.stop.prevent=\"hoverNextOption()\"\n        @keydown.right.stop.prevent=\"hoverNextOption()\"\n        @keydown.enter.prevent=\"selectOrAddOption()\"\n        @focus=\"hoveredOption = null\"\n      />\n      <div class=\"va-select-dropdown__options-wrapper\">\n        <va-select-option-list\n          ref=\"optionList\"\n          v-model:hoveredOption=\"hoveredOption\"\n          :style=\"{ maxHeight: $props.maxHeight }\"\n          :options=\"filteredOptions\"\n          :selected-value=\"valueComputed\"\n          :get-selected-state=\"checkIsOptionSelected\"\n          :get-text=\"getText\"\n          :get-track-by=\"getTrackBy\"\n          :get-group-by=\"getGroupBy\"\n          :search=\"searchInput\"\n          :no-options-text=\"$props.noOptionsText\"\n          :color=\"$props.color\"\n          :tabindex=\"tabindex + 1\"\n          @select-option=\"selectOption\"\n          @no-previous-option-to-hover=\"focusSearchBar()\"\n          @keydown.enter.stop.prevent=\"selectHoveredOption()\"\n          @keydown.space.stop.prevent=\"selectHoveredOption()\"\n          @keydown.tab.stop.prevent=\"searchBar && searchBar.focus()\"\n          @keydown=\"onHintedSearch\"\n          @scroll-bottom=\"onScrollBottom\"\n        />\n      </div>\n    </va-dropdown-content>\n  </va-dropdown>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, ref, computed, watch, nextTick } from 'vue'\n\nimport { useSelectableList, useSelectableListProps, SelectableOption } from '../../composables/useSelectableList'\nimport { useValidation, useValidationProps, useValidationEmits } from '../../composables/useValidation'\nimport { useFormProps } from '../../composables/useForm'\nimport { useLoadingProps } from '../../composables/useLoading'\nimport { useColor } from '../../composables/useColor'\nimport { useMaxSelections, useMaxSelectionsProps } from '../../composables/useMaxSelections'\nimport { useClearableProps, useClearable, useClearableEmits } from '../../composables/useClearable'\nimport { useColors } from '../../services/color-config/color-config'\nimport { warn } from '../../services/utils'\nimport VaDropdown, { VaDropdownContent } from '../va-dropdown'\nimport VaIcon from '../va-icon'\nimport VaInput from '../va-input'\nimport VaSelectOptionList from './VaSelectOptionList'\n\nconst { getHoverColor } = useColors()\n\ntype DropdownIcon = {\n  open: string,\n  close: string\n}\n\nexport default defineComponent({\n  name: 'VaSelect',\n\n  components: {\n    VaSelectOptionList,\n    VaIcon,\n    VaDropdown,\n    VaDropdownContent,\n    VaInput,\n  },\n\n  emits: [\n    'update:modelValue',\n    'update-search',\n    'create-new',\n    'scroll-bottom',\n    ...useValidationEmits,\n    ...useClearableEmits,\n  ],\n\n  props: {\n    ...useSelectableListProps,\n    ...useValidationProps,\n    ...useLoadingProps,\n    ...useMaxSelectionsProps,\n    ...useClearableProps,\n    ...useFormProps,\n\n    modelValue: {\n      type: [String, Number, Object] as PropType<SelectableOption>,\n      default: '',\n    },\n\n    // Dropdown position\n    position: {\n      type: String as PropType<string>,\n      default: 'bottom',\n      validator: (position: string) => ['top', 'bottom'].includes(position),\n    },\n\n    allowCreate: {\n      type: [Boolean, String] as PropType<boolean | string>,\n      default: false,\n      validator: (mode: string | boolean) => {\n        return [true, false, 'unique'].includes(mode)\n      },\n    },\n\n    color: { type: String as PropType<string>, default: 'primary' },\n    multiple: { type: Boolean as PropType<boolean>, default: false },\n    searchable: { type: Boolean as PropType<boolean>, default: false },\n    separator: { type: String as PropType<string>, default: ', ' },\n    width: { type: String as PropType<string>, default: '100%' },\n    maxHeight: { type: String as PropType<string>, default: '256px' },\n    noOptionsText: { type: String as PropType<string>, default: 'Items not found' },\n    fixed: { type: Boolean as PropType<boolean>, default: true },\n    hideSelected: { type: Boolean as PropType<boolean>, default: false },\n    tabindex: { type: Number as PropType<number>, default: 0 },\n    dropdownIcon: {\n      type: [String, Object] as PropType<string | DropdownIcon>,\n      default: (): DropdownIcon => ({\n        open: 'expand_more',\n        close: 'expand_less',\n      }),\n      validator: (value: any) => {\n        if (typeof value === 'string') { return true }\n\n        const isOpenIconString = typeof value.open === 'string'\n        const isCloseIconString = typeof value.close === 'string'\n\n        return isOpenIconString && isCloseIconString\n      },\n    },\n\n    // Input style\n    outline: { type: Boolean as PropType<boolean>, default: false },\n    bordered: { type: Boolean as PropType<boolean>, default: false },\n    label: { type: String as PropType<string>, default: '' },\n    placeholder: { type: String as PropType<string>, default: '' },\n    requiredMark: { type: Boolean as PropType<boolean>, default: false },\n  },\n\n  setup (props, { emit }) {\n    const optionList = ref<InstanceType<typeof VaSelectOptionList>>()\n    const input = ref<InstanceType<typeof VaInput>>()\n    const searchBar = ref<InstanceType<typeof VaInput>>()\n\n    const { getOptionByValue, getValue, getText, getTrackBy, getGroupBy } = useSelectableList(props)\n\n    const {\n      isFocused,\n      validate,\n      computedError,\n      computedErrorMessages,\n    } = useValidation(props, emit, () => reset(), () => focus())\n\n    const { colorComputed } = useColor(props)\n    const toggleIconColor = computed(() => (\n      props.readonly ? getHoverColor(colorComputed.value) : colorComputed.value\n    ))\n\n    const onScrollBottom = () => {\n      emit('scroll-bottom')\n    }\n\n    const searchInput = ref('')\n    const showSearchInput = computed(() => {\n      return props.searchable || props.allowCreate\n    })\n\n    watch(() => searchInput.value, (value) => {\n      emit('update-search', value)\n      hoveredOption.value = null\n    })\n\n    // Select value\n\n    const valueComputed = computed({\n      get () {\n        const value = getOptionByValue(props.modelValue)\n\n        if (props.multiple) {\n          if (!value) {\n            return []\n          }\n\n          if (!Array.isArray(value)) {\n            return [value]\n          }\n\n          return value\n        }\n\n        if (Array.isArray(value)) {\n          warn('Model value should be a string or a number for a single Select.')\n\n          if (value.length) {\n            return value[value.length - 1]\n          }\n        }\n\n        return value\n      },\n\n      set (value: any) {\n        emit('update:modelValue', getValue(value))\n      },\n    })\n\n    const valueComputedString = computed((): string | number => {\n      if (!valueComputed.value) { return props.clearValue }\n      if (typeof valueComputed.value === 'string' || typeof valueComputed.value === 'number') { return valueComputed.value }\n      if (Array.isArray(valueComputed.value)) {\n        return valueComputed.value.map((value) => getText(value)).join(props.separator) || props.clearValue\n      }\n\n      return getText(valueComputed.value)\n    })\n\n    // Icons\n    const {\n      canBeCleared,\n      clearIconProps,\n    } = useClearable(props, valueComputed, isFocused, computedError)\n\n    const showClearIcon = computed(() => {\n      if (props.multiple) { return !!valueComputed.value.length }\n      return canBeCleared.value\n    })\n\n    const toggleIcon = computed((): string => {\n      if (!props.dropdownIcon) { return '' }\n\n      if (typeof props.dropdownIcon === 'string') {\n        return props.dropdownIcon\n      }\n\n      return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open\n    })\n\n    // Options\n\n    const filteredOptions = computed((): any[] => {\n      if (!props.options) { return [] }\n\n      if (props.hideSelected) {\n        return (props.options).filter((option) => !checkIsOptionSelected(option))\n      }\n\n      return props.options\n    })\n\n    const checkIsOptionSelected = (option: any): boolean => {\n      if (!valueComputed.value) { return false }\n\n      if (Array.isArray(valueComputed.value)) {\n        return !!valueComputed.value.find((valueItem: any) => compareOptions(valueItem, option))\n      }\n\n      return compareOptions(valueComputed.value, option)\n    }\n\n    const compareOptions = (one: any, two: any) => {\n      // identity check works nice for strings and exact matches.\n      if (one === two) {\n        return true\n      }\n      if (typeof one === 'string' && typeof two === 'string') {\n        return one === two\n      }\n      if (one === null || two === null) {\n        return false\n      }\n      if (typeof one === 'object' && typeof two === 'object') {\n        return getTrackBy(one) === getTrackBy(two)\n      }\n\n      return false\n    }\n\n    const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections), emit)\n\n    const selectOption = (option: any): void => {\n      if (hoveredOption.value === null) {\n        hideDropdown()\n        return\n      }\n\n      if (showSearchInput.value) {\n        searchInput.value = ''\n      }\n\n      if (props.multiple) {\n        const isSelected = checkIsOptionSelected(option)\n\n        if (isSelected) {\n          // Unselect\n          valueComputed.value = valueComputed.value.filter((optionSelected: any) => !compareOptions(option, optionSelected))\n        } else {\n          if (exceedsMaxSelections()) { return }\n          addOption(option)\n        }\n      } else {\n        valueComputed.value = typeof option === 'string' || typeof option === 'number' ? option : { ...option }\n        hideDropdown()\n      }\n    }\n\n    const selectOrAddOption = () => {\n      if (hoveredOption.value !== null) {\n        selectHoveredOption()\n        return\n      }\n\n      if (allowedToCreate()) {\n        addNewOption()\n      }\n    }\n\n    const allowedToCreate = (): boolean => {\n      return !!(props.allowCreate && searchInput.value !== '')\n    }\n\n    const addNewOption = (): void => {\n      // Do not emit if option already exist and allow create is `unique`\n      const hasAddedOption: boolean = props.options?.some((option: any) => getText(option) === searchInput.value)\n\n      if (!(props.allowCreate === 'unique' && hasAddedOption)) {\n        emit('create-new', searchInput.value)\n        searchInput.value = ''\n      }\n    }\n\n    // Hovered options\n\n    const hoveredOption = ref(null as any)\n\n    const selectHoveredOption = () => {\n      if (!showDropdownContent.value) {\n        // We can not select options if they are hidden\n        showDropdown()\n        return\n      }\n\n      selectOption(hoveredOption.value)\n    }\n\n    const hoverPreviousOption = () => {\n      optionList.value?.hoverPreviousOption()\n    }\n\n    const hoverNextOption = () => {\n      optionList.value?.hoverNextOption()\n    }\n\n    // Dropdown content\n\n    const showDropdownContent = ref(false)\n\n    const showDropdownContentComputed = computed({\n      get: () => {\n        return showDropdownContent.value\n      },\n      set: (show: boolean) => {\n        show\n          ? showDropdown()\n          : hideDropdown()\n      },\n    })\n\n    const closeOnContentClick = computed(() => {\n      return !(props.multiple || props.searchable || props.allowCreate)\n    })\n\n    const showDropdown = () => {\n      if (props.disabled || props.readonly) { return }\n\n      showDropdownContent.value = true\n      scrollToSelected()\n      focusSearchOrOptions()\n    }\n\n    const hideDropdown = () => {\n      showDropdownContent.value = false\n      searchInput.value = ''\n      validate()\n      input.value?.focus()\n    }\n\n    const toggleDropdown = () => {\n      if (showDropdownContent.value) {\n        hideDropdown()\n      } else {\n        showDropdown()\n      }\n    }\n\n    const onSelectClick = () => {\n      if (props.disabled || props.readonly) { return }\n      toggleDropdown()\n    }\n\n    const focusSearchBar = () => {\n      searchBar.value?.focus()\n    }\n\n    const focusOptionList = () => {\n      optionList.value?.focus()\n      optionList.value?.hoverFirstOption()\n    }\n\n    const focusSearchOrOptions = () => {\n      nextTick(() => {\n        if (showSearchInput.value) {\n          focusSearchBar()\n        } else { focusOptionList() }\n      })\n    }\n\n    const onInputFocus = (): void => {\n      if (!isFocused.value) {\n        isFocused.value = true\n      }\n    }\n\n    const onInputBlur = (): void => {\n      if (!showDropdownContentComputed.value) {\n        isFocused.value\n          ? isFocused.value = false\n          : validate()\n      }\n    }\n\n    /** @public */\n    const focus = (): void => {\n      if (props.disabled) { return }\n      input.value?.focus()\n    }\n\n    /** @public */\n    const blur = (): void => {\n      if (showDropdownContentComputed.value) {\n        showDropdownContentComputed.value = false\n        nextTick(() => {\n          input.value?.blur()\n        })\n      } else {\n        input.value?.blur()\n      }\n    }\n\n    /** @public */\n    const reset = (): void => {\n      if (props.multiple) {\n        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : []\n      } else {\n        valueComputed.value = props.clearValue\n      }\n\n      searchInput.value = ''\n      emit('clear')\n    }\n\n    const tabIndexComputed = computed(() => {\n      return props.disabled ? -1 : props.tabindex\n    })\n\n    const scrollToSelected = (): void => {\n      const selected = valueComputed.value\n      const nothingSelected = !selected.length && typeof selected !== 'object'\n\n      if (nothingSelected) {\n        return\n      }\n\n      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected\n      hoveredOption.value = scrollTo\n      nextTick(() => optionList.value?.scrollToOption(scrollTo))\n    }\n\n    // Hinted search\n\n    let hintedSearchQuery = ''\n    let hintedSearchQueryTimeoutIndex!: any\n    const navigationKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', ' ']\n\n    // Hinted search - hover option if you typing it's value on select without search-bar\n    const onHintedSearch = (event: KeyboardEvent) => {\n      if (navigationKeys.some(key => key === event.key)) {\n        return\n      }\n\n      const isLetter: boolean = event.key.length === 1\n      const isDeleteKey: boolean = event.key === 'Backspace' || event.key === 'Delete'\n\n      clearTimeout(hintedSearchQueryTimeoutIndex)\n\n      if (isDeleteKey) {\n        // Remove last letter from query\n        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : ''\n      } else if (isLetter) {\n        // Add every new letter to the query\n        hintedSearchQuery += event.key\n      }\n\n      if (showSearchInput.value) {\n        searchInput.value = hintedSearchQuery\n        return\n      }\n\n      // Search for an option that matches the query\n      if (hintedSearchQuery) {\n        const appropriateOption = props.options.find(option => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()))\n        if (appropriateOption) {\n          hoveredOption.value = appropriateOption\n        }\n      }\n\n      hintedSearchQueryTimeoutIndex = setTimeout(() => { hintedSearchQuery = '' }, 1000)\n    }\n\n    return {\n      input,\n      optionList,\n      searchBar,\n\n      // while we have problem with 'withConfigTransport'\n      // focus,\n      // blur,\n\n      onInputFocus,\n      onInputBlur,\n      focusOptionList,\n      reset,\n      onSelectClick,\n      focusSearchBar,\n      searchInput,\n      showSearchInput,\n      hoveredOption,\n      tabIndexComputed,\n      valueComputed,\n      valueComputedString,\n      showClearIcon,\n      toggleIcon,\n      computedErrorMessages,\n      computedError,\n      filteredOptions,\n      checkIsOptionSelected,\n      closeOnContentClick,\n      selectOption,\n      selectOrAddOption,\n      selectHoveredOption,\n      hoverPreviousOption,\n      hoverNextOption,\n      showDropdownContentComputed,\n      showDropdown,\n      hideDropdown,\n      toggleDropdown,\n      toggleIconColor,\n      onHintedSearch,\n      getText,\n      getTrackBy,\n      getGroupBy,\n      onScrollBottom,\n      clearIconProps,\n    }\n  },\n  // we will use this while we have problem with 'withConfigTransport'\n  methods: {\n    focus () {\n      if (this.$props.disabled) { return }\n      this.input?.focus()\n    },\n    blur () {\n      if (this.showDropdownContentComputed) {\n        this.showDropdownContentComputed = false\n        nextTick(() => {\n          this.input?.blur()\n        })\n      } else {\n        this.input?.blur()\n      }\n    },\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-select {\n  cursor: var(--va-select-cursor);\n\n  .va-input {\n    cursor: var(--va-select-cursor);\n  }\n}\n\n.va-select-dropdown {\n  .va-dropdown__anchor {\n    display: block;\n  }\n\n  &__content {\n    overflow: hidden;\n    border-bottom-right-radius: var(--va-select-dropdown-border-radius);\n    border-bottom-left-radius: var(--va-select-dropdown-border-radius);\n    border-top-right-radius: 0;\n    border-top-left-radius: 0;\n    box-shadow: var(--va-select-box-shadow);\n    padding: 0;\n  }\n\n  &__options-wrapper {\n    background: var(--va-select-dropdown-background);\n    overflow-y: auto;\n\n    @include va-scroll(var(--va-select-scroll-color));\n  }\n}\n\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport VaSelect from './VaSelect.vue'\nimport VaSelectOptionListBase from './VaSelectOptionList/VaSelectOptionList.vue'\n\nexport const VaSelectOptionList = withConfigTransport(VaSelectOptionListBase)\n\nexport default withConfigTransport(VaSelect)\n"],"names":["useMaxSelectionsProps","maxSelections","type","Number","String","default","undefined","defineComponent","name","components","VaIcon","emits","props","useColorProps","options","Array","noOptionsText","getSelectedState","Function","required","getText","getTrackBy","getGroupBy","multiple","Boolean","search","tabindex","hoveredOption","Object","setup","emit","getColor","useColors","itemRefs","ref","rootElement","hoveredOptionComputed","computed","get","set","value","filteredOptions","filter","option","optionText","toString","toUpperCase","includes","optionGroups","reduce","groups","group","groupBy","push","_noGroup","isHovered","updateHoveredOption","hoveredOptionIndex","findIndex","watch","newOption","element","scrollTarget","parentElement","verticalAlignment","smooth","top","viewHeight","offsetHeight","currentPosition","scrollTop","offsetTop","getTopCoordinate","center","getCenterCoordinate","bottom","getBottomCoordinate","getScrollTop","scroll","behavior","scrollToElement","scrollToOption","publicMethods","hoverPreviousOption","length","at","hoverNextOption","hoverFirstOption","focus","preventScroll","onScroll","target","clientHeight","scrollHeight","beforeUpdate","setItemRef","el","selectOption","getOptionIcon","icon","getOptionClass","getOptionStyle","color","backgroundColor","getHoverColor","methods","this","class","_createElementBlock","_ctx","onKeydown","groupName","_hoisted_2","key","style","onClick","onMouseover","_createBlock","size","_createElementVNode","_createVNode","_hoisted_4","withConfigTransport","VaSelectOptionList","VaDropdown","VaDropdownContent","VaInput","useValidationEmits","useClearableEmits","useSelectableListProps","useValidationProps","useLoadingProps","useClearableProps","useFormProps","modelValue","position","validator","allowCreate","mode","searchable","separator","width","maxHeight","fixed","hideSelected","dropdownIcon","open","close","isOpenIconString","isCloseIconString","outline","bordered","label","placeholder","requiredMark","optionList","input","searchBar","getOptionByValue","getValue","useSelectableList","isFocused","validate","computedError","computedErrorMessages","useValidation","reset","colorComputed","useColor","toggleIconColor","readonly","searchInput","showSearchInput","valueComputed","isArray","warn","valueComputedString","map","join","clearValue","canBeCleared","clearIconProps","useClearable","showClearIcon","toggleIcon","showDropdownContent","checkIsOptionSelected","find","valueItem","compareOptions","one","two","exceedsMaxSelections","addOption","useMaxSelections","selections","isNaN","optionToAdd","newSelectedOptions","optionSelected","hideDropdown","allowedToCreate","addNewOption","hasAddedOption","some","selectHoveredOption","showDropdown","showDropdownContentComputed","show","closeOnContentClick","disabled","scrollToSelected","focusSearchOrOptions","toggleDropdown","focusSearchBar","focusOptionList","nextTick","tabIndexComputed","selected","scrollTo","hintedSearchQueryTimeoutIndex","hintedSearchQuery","navigationKeys","onInputFocus","onInputBlur","onSelectClick","selectOrAddOption","onHintedSearch","event","isLetter","isDeleteKey","clearTimeout","slice","appropriateOption","toLowerCase","startsWith","setTimeout","onScrollBottom","$props","blur","trigger","anchorSelector","stateful","offset","anchor","_hoisted_1","success","error","loading","messages","onFocus","onBlur","_mergeProps","appendInner","_renderSlot","onKeyup","onSelectOption","onNoPreviousOptionToHover","VaSelectOptionListBase","VaSelect"],"mappings":"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"}