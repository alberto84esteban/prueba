{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { computed as e } from \"vue\";\n\nfunction normalizeProps(e) {\n  switch (!0) {\n    case Array.isArray(e):\n      return e.reduce((e, t) => ({ ...e,\n        [t]: null\n      }), {});\n\n    case \"object\" == typeof e && null !== e:\n      return e;\n\n    default:\n      return {};\n  }\n}\n\nfunction mergeProps(e, t, o = \"props\") {\n  const {\n    mixins: n,\n    extends: r\n  } = t;\n  r && mergeProps(e, r, o), n && n.forEach(t => mergeProps(e, t, o));\n  const s = normalizeProps(t[o]);\n\n  for (const t in s) e[t] = s[t];\n}\n\nconst getComponentProps = e => function resolveProps(e, t = \"props\") {\n  var o, n;\n  const r = null !== (o = e.mixins) && void 0 !== o ? o : [],\n        s = {};\n  mergeProps(s, null !== (n = e.extends) && void 0 !== n ? n : [], t);\n\n  for (let e = 0; e < r.length; e++) mergeProps(s, r[e], t);\n\n  return Object.assign(s, normalizeProps(e[t])), s;\n}(function getComponentOptions(e) {\n  return e.options ? e.options : e.__vccOpts || e.__b ? { ...e.__vccOpts,\n    ...e.__b\n  } : e;\n}(e)),\n      filterComponentProps = (t, o) => e(() => Object.keys(o).reduce((e, o) => (e[o] = t[o], e), {}));\n\nfunction extractComponentProps(e, t) {\n  const o = getComponentProps(e);\n  return t ? Object.keys(o).reduce((e, n) => (t.includes(n) || void 0 === o[n] || (e[n] = \"string\" == typeof o[n] ? {} : o[n]), e), {}) : o;\n}\n\nfunction extractComponentEmits(e) {\n  return [...new Set(e.emits)];\n}\n\nexport { extractComponentEmits as a, extractComponentProps as e, filterComponentProps as f };","map":{"version":3,"mappings":"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","names":["normalizeProps","props","Array","isArray","reduce","acc","prop","mergeProps","to","from","optionsType","mixins","extends","extendsOptions","forEach","m","key","getComponentProps","component","resolveProps","options","result","i","length","Object","assign","getComponentOptions","__vccOpts","__b","filterComponentProps","propsValues","childProps","computed","keys","propName","extractComponentProps","ignoreProps","includes","undefined","extractComponentEmits","Set","emits"],"sources":["../../src/utils/resolve-class-component-props.ts","../../src/utils/child-props.ts"],"sourcesContent":["import { ComponentOptions, DefineComponent } from 'vue'\n\nfunction normalizeProps (props: any) {\n  switch (true) {\n  case Array.isArray(props):\n    return props.reduce((acc: Record<string, unknown>, prop: string) => ({ ...acc, [prop]: null }), {})\n  case typeof props === 'object' && props !== null:\n    return props\n  default:\n    return {}\n  }\n}\n\nfunction mergeProps (to: Record<string, any>, from: Record<string, any>, optionsType = 'props') {\n  const { mixins, extends: extendsOptions } = from\n\n  extendsOptions && mergeProps(to, extendsOptions, optionsType)\n  mixins && mixins.forEach((m: any) => mergeProps(to, m, optionsType))\n\n  const props = normalizeProps(from[optionsType])\n\n  for (const key in props) {\n    to[key] = props[key]\n  }\n}\n\nfunction getComponentOptions (component: DefineComponent): ComponentOptions {\n  if (component.options) {\n    return component.options\n  }\n\n  if (component.__vccOpts || component.__b) {\n    return { ...component.__vccOpts, ...component.__b }\n  }\n\n  return component\n}\n\nfunction resolveProps (options: any, optionsType = 'props') {\n  const mixins = options.mixins ?? []\n  const extendsOptions = options.extends ?? []\n  const result: Record<string, any> = {}\n\n  mergeProps(result, extendsOptions, optionsType)\n\n  for (let i = 0; i < mixins.length; i++) {\n    mergeProps(result, mixins[i], optionsType)\n  }\n\n  Object.assign(result, normalizeProps(options[optionsType]))\n\n  return result\n}\n\nexport const getComponentProps = (component: DefineComponent) => {\n  return resolveProps(getComponentOptions(component))\n}\n","import { ComponentOptionsBase, PropType, computed, ComputedRef, Prop, DefineComponent } from 'vue'\nimport { getComponentProps } from './resolve-class-component-props'\n\n/**\n * Accepts parent component props and return value only for child component props.\n *\n * Used to proxy child component props from parent.\n */\nexport const filterComponentProps = <T extends Record<string, unknown>, K extends Record<keyof T, unknown>>(propsValues: K, childProps: T) => {\n  return computed(() => {\n    return Object\n      .keys(childProps)\n      .reduce((acc, propName: keyof T) => {\n        acc[propName] = propsValues[propName]\n        return acc\n      }, {} as { [K in keyof T]: typeof propsValues[K] })\n  })\n}\n\n// Define component\ndeclare type DefineComponentOptions = ComponentOptionsBase<any, any, any, any, any, any, any, any>\n\n// ExtractOptionProp taken from Vue3 source code\ndeclare type ExtractDefineComponentOptionProp<T> = T extends ComponentOptionsBase<infer P, any, any, any, any, any, any, any> ? unknown extends P ? {} : P : {};\n// Remove useless readonly and nullable key here:\n// -readonly removes readonly\n// -? removes undefined from key, so we can be sure that prop exists and should have type.\ndeclare type ExtractDefineComponentPropsType<T> = {\n  -readonly [K in keyof ExtractDefineComponentOptionProp<T>]-?: {\n    type: PropType<ExtractDefineComponentOptionProp<T>[K]>,\n    required: undefined extends ExtractDefineComponentOptionProp<T>[K] ? false: true,\n  }\n}\n\n// Class component\ndeclare type ClassComponent = { prototype: { $props: unknown }}\n\ndeclare type ExtractClassComponentOptionProp<T extends ClassComponent> = T['prototype']['$props']\n\ndeclare type ExtractClassComponentPropsType<T extends ClassComponent> = {\n  -readonly [K in keyof ExtractClassComponentOptionProp<T>]-?: {\n    type: PropType<ExtractClassComponentOptionProp<T>[K]>,\n    required: undefined extends ExtractClassComponentOptionProp<T>[K] ? false: true,\n  }\n}\n\ndeclare type ExtractComponentProps<T extends ClassComponent | DefineComponentOptions> = T extends DefineComponentOptions ? ExtractDefineComponentPropsType<T> :\n  T extends ClassComponent ? ExtractClassComponentPropsType<T> : never\n\n/**\n * Works only with defineComponent function.\n * @notion Be aware that `withConfigTransport` you will lose prop types\n */\nexport function extractComponentProps<T> (component: T, ignoreProps?: string[]): ExtractComponentProps<T> {\n  const props: any = getComponentProps(component as any)\n\n  if (ignoreProps) {\n    return Object\n      .keys(props)\n      .reduce<Record<string, unknown>>((acc, propName) => {\n        if (ignoreProps.includes(propName)) { return acc }\n\n        if (props[propName] === undefined) { return acc }\n\n        acc[propName] = typeof props[propName] === 'string' ? {} : props[propName]\n\n        return acc\n      }, {}) as ExtractComponentProps<T>\n  }\n\n  return props\n}\n\ndeclare type ExtractEmitsType<T> = T extends ComponentOptionsBase<any, any, any, any, any, any, any, infer E> ? E: []\n\nexport function extractComponentEmits<T> (component: T): ExtractEmitsType<T> {\n  return [...new Set((component as any).emits)] as any\n}\n"]},"metadata":{},"sourceType":"module"}