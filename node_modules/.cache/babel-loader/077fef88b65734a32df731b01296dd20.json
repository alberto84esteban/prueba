{"ast":null,"code":"import { ref as e, computed as t } from \"vue\";\nconst u = {\n  stateful: {\n    type: Boolean,\n    default: !1\n  },\n  modelValue: {\n    type: void 0\n  }\n},\n      a = [\"update:modelValue\"];\n\nfunction useStateful(u, a, l) {\n  const o = e(void 0 === l ? u.modelValue : l);\n  return {\n    valueComputed: t({\n      get: () => u.stateful ? o.value : u.modelValue,\n\n      set(e) {\n        u.stateful && (o.value = e), a(\"update:modelValue\", e);\n      }\n\n    })\n  };\n}\n\nexport { useStateful as a, a as b, u };","map":{"version":3,"mappings":";MAcaA,IAAmB;AAC9BC,YAAU;AAAEC,UAAMC,OAAR;AAAsCC,cAAS;AAA/C,GADoB;AAE9BC,cAAY;AAAEH,eAAMI;AAAR;AAFkB;MAKnBC,IAAmB,CAAC,mBAAD;;AAAC,SAOjBC,WAPiB,CAQ/BC,CAR+B,EAS/BC,CAT+B,EAU/BC,CAV+B,EAU/BA;AAEA,QAAMC,IAAaC,OAAqBP,CAArBO,KAAIF,CAAJE,GAAiCJ,EAAMJ,UAAvCQ,GAAoDF,CAApDE,CAAnB;AAiBA,SAAO;AAAEC,mBAfaC,EAAS;AAC7BC,WAAG,MACGP,EAAMR,QAANQ,GACKG,EAAWK,KADhBR,GAGGA,EAAMJ,UALc;;AAO7Ba,UAAKD,CAALC,EAAKD;AACCR,UAAMR,QAANQ,KACFG,EAAWK,KAAXL,GAAmBK,CADjBR,GAGJC,EAAK,mBAALA,EAA0BO,CAA1BP,CAHID;AAGsBQ;;AAXC,KAATF;AAef,GAAP;AAJ8BE;;AAAAA","names":["useStatefulProps","stateful","type","Boolean","default","modelValue","undefined","useStatefulEmits","useStateful","props","emit","defaultValue","valueState","ref","valueComputed","computed","get","value","set"],"sources":["../../src/composables/useStateful.ts"],"sourcesContent":["import { ref, computed, PropType } from 'vue'\n\nexport type StatefulProps<T> = {\n  stateful: boolean\n  modelValue: T\n  [prop: string]: unknown\n}\n\n/**\n * You could add these props to any component by destructuring them inside props option.\n * @example\n * props: { ...useStatefulProps, componentsOwnProp, etc. }\n * It's better to add props at the beginning, to make sure that Component own props will be used instead in case of collision\n */\nexport const useStatefulProps = {\n  stateful: { type: Boolean as PropType<boolean>, default: false },\n  modelValue: { type: undefined as any as PropType<unknown> },\n}\n\nexport const useStatefulEmits = ['update:modelValue']\n\n/**\n * Returns `valueComputed` that is proxy for `modelValue`\n * if `stateful` prop is `false`\n * Record<any, any> & Record<'modelValue', T>\n */\nexport function useStateful<T, D extends T | undefined> (\n  props: StatefulProps<T>,\n  emit: (event: 'update:modelValue', newValue: T) => void,\n  defaultValue?: D,\n) {\n  const valueState = ref(defaultValue === undefined ? props.modelValue : defaultValue)\n\n  const valueComputed = computed({\n    get () {\n      if (props.stateful) {\n        return valueState.value\n      }\n      return props.modelValue\n    },\n    set (value: any) {\n      if (props.stateful) {\n        valueState.value = value\n      }\n      emit('update:modelValue', value)\n    },\n  })\n\n  return { valueComputed }\n}\n"]},"metadata":{},"sourceType":"module"}