{"ast":null,"code":"import { w as e } from \"./withConfigTransport.js\";\nimport { a as l } from \"./debounce.js\";\nimport { onMounted as i, onBeforeUnmount as r, defineComponent as n, ref as t, computed as o, watch as s, resolveComponent as a, openBlock as v, createBlock as c, resolveDynamicComponent as u, normalizeClass as f, withCtx as d, renderSlot as p, createElementVNode as m, createVNode as g, createCommentVNode as h } from \"vue\";\nimport { s as _ } from \"./utils.js\";\nimport { u as y } from \"./useColor.js\";\nimport { VaProgressCircle as b } from \"./index39.js\";\nimport { s as j } from \"./style-inject.es.js\";\nimport \"./VaConfig.js\";\nimport \"./toNumber.js\";\nimport \"./color-config.js\";\nimport \"colortranslator\";\nimport \"./clamp.js\";\nimport \"./useSize.js\";\nvar S = n({\n  name: \"VaInfiniteScroll\",\n  components: {\n    VaProgressCircle: b\n  },\n  props: {\n    load: {\n      type: Function,\n      required: !0\n    },\n    offset: {\n      type: Number,\n      default: 500\n    },\n    reverse: {\n      type: Boolean,\n      default: !1\n    },\n    disabled: {\n      type: Boolean,\n      default: !1\n    },\n    scrollTarget: {\n      type: [Element, String],\n      default: null\n    },\n    debounce: {\n      type: Number,\n      default: 100\n    },\n    tag: {\n      type: String,\n      default: \"div\"\n    }\n  },\n  emits: [\"onload\", \"onerror\"],\n\n  setup(e, {\n    emit: n\n  }) {\n    const a = t(),\n          v = t(),\n          c = t(!1),\n          u = t(!1),\n          f = t(!1),\n          d = t(),\n          p = t(0),\n          m = t(0),\n          g = o(() => {\n      var l;\n      let i;\n      return i = \"string\" == typeof e.scrollTarget ? document.querySelector(e.scrollTarget) : e.scrollTarget || (null === (l = a.value) || void 0 === l ? void 0 : l.parentElement), i || document.body;\n    }),\n          {\n      addScrollListener: h,\n      removeScrollListener: b\n    } = ((e, l, n) => {\n      const addScrollListener = () => {\n        var e;\n        null === (e = l.value) || void 0 === e || e.addEventListener(\"scroll\", n.value, {\n          passive: !0\n        });\n      },\n            removeScrollListener = () => {\n        var e;\n        null === (e = l.value) || void 0 === e || e.removeEventListener(\"scroll\", n.value);\n      };\n\n      return i(() => {\n        l.value && (l.value.style.overflowY = \"scroll\", e.reverse && (l.value.scrollTop = l.value.scrollHeight), addScrollListener());\n      }), r(removeScrollListener), {\n        addScrollListener: addScrollListener,\n        removeScrollListener: removeScrollListener\n      };\n    })(e, g, d),\n          {\n      computeColor: j\n    } = y(e),\n          S = o(() => u.value ? j(\"danger\") : j(\"primary\")),\n          x = o(() => {\n      var e;\n      return (null === (e = v.value) || void 0 === e ? void 0 : e.offsetHeight) || 0;\n    }),\n          C = o(() => e.offset + x.value),\n          stop = () => {\n      e.disabled || (c.value = !1, b());\n    },\n          resume = () => {\n      e.disabled || h();\n    },\n          onLoad = () => {\n      const {\n        scrollTop: l,\n        scrollHeight: i,\n        clientHeight: r\n      } = g.value;\n      p.value = i - l;\n      const n = l - m.value;\n      if (m.value = l, e.disabled || u.value || c.value) return;\n      if (f.value) return void (f.value = !1);\n      if (e.reverse && n > 0 || !e.reverse && n < 0) return;\n      (e.reverse ? l : i - l - r) > C.value || (c.value = !0, e.load().then(finishLoading).catch(onError));\n    },\n          forceSetScrollTopToTarget = e => {\n      f.value = !0, g.value.scrollTop = e;\n    },\n          updateTargetElementScrollTop = () => {\n      const {\n        scrollTop: l,\n        scrollHeight: i,\n        clientHeight: r\n      } = g.value;\n\n      if (e.reverse) {\n        const e = i - l < p.value,\n              r = l >= x.value;\n        if (e && r) return;\n        i - p.value > x.value ? forceSetScrollTopToTarget(i - p.value) : forceSetScrollTopToTarget(x.value);\n      }\n\n      if (!e.reverse) {\n        !(i - l - r >= x.value) && forceSetScrollTopToTarget(i - r - x.value);\n      }\n    },\n          finishLoading = () => {\n      updateTargetElementScrollTop(), c.value = !1, n(\"onload\");\n    },\n          stopErrorDisplay = () => {\n      updateTargetElementScrollTop(), f.value = !1, u.value = !1, c.value = !1, n(\"onerror\");\n    },\n          onError = () => {\n      stop(), u.value = !0, _(1200).then(stopErrorDisplay).then(resume);\n    };\n\n    return s(() => e.debounce, e => {\n      d.value = l(onLoad, e);\n    }, {\n      immediate: !0\n    }), s(() => e.disabled, e => {\n      e ? stop() : resume();\n    }), {\n      element: a,\n      spinnerSlotContainer: v,\n      spinnerColor: S,\n      fetching: c\n    };\n  }\n\n});\nconst x = {\n  class: \"va-infinite-scroll__spinner__default\"\n};\nj(\":root{--va-infinite-scroll-display:flex;--va-infinite-scroll-flex-direction:column;--va-infinite-scroll-spinner-default-width:100%;--va-infinite-scroll-spinner-default-min-height:70px;--va-infinite-scroll-reversed-flex-direction:column-reverse}.va-infinite-scroll{display:var(--va-infinite-scroll-display);flex-direction:var(--va-infinite-scroll-flex-direction);font-family:var(--va-font-family)}.va-infinite-scroll--reversed{flex-direction:var(--va-infinite-scroll-reversed-flex-direction)}.va-infinite-scroll__spinner,.va-infinite-scroll__spinner__default{align-items:center;display:flex;justify-content:center}.va-infinite-scroll__spinner__default{min-height:var(--va-infinite-scroll-spinner-default-min-height);width:var(--va-infinite-scroll-spinner-default-width)}.va-infinite-scroll__spinner--invisible{visibility:hidden!important}\"), S.render = function render(e, l, i, r, n, t) {\n  const o = a(\"va-progress-circle\");\n  return v(), c(u(e.$props.tag), {\n    class: f([\"va-infinite-scroll\", {\n      \"va-infinite-scroll--reversed\": e.$props.reverse\n    }]),\n    ref: \"element\"\n  }, {\n    default: d(() => [p(e.$slots, \"default\"), m(\"div\", {\n      class: f([\"va-infinite-scroll__spinner\", {\n        \"va-infinite-scroll__spinner--invisible\": !e.fetching\n      }]),\n      ref: \"spinnerSlotContainer\"\n    }, [e.$props.disabled ? h(\"v-if\", !0) : p(e.$slots, \"loading\", {\n      key: 0\n    }, () => [m(\"div\", x, [g(o, {\n      size: \"small\",\n      thickness: .15,\n      color: e.spinnerColor,\n      indeterminate: \"\"\n    }, null, 8, [\"thickness\", \"color\"])])])], 2)]),\n    _: 3\n  }, 8, [\"class\"]);\n}, S.__file = \"src/components/va-infinite-scroll/VaInfiniteScroll.vue\";\nvar C = e(S);\nexport { C as default };","map":{"version":3,"mappings":"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","names":["defineComponent","name","components","VaProgressCircle","props","load","type","Function","required","offset","Number","default","reverse","Boolean","disabled","scrollTarget","Element","String","debounce","tag","emits","setup","emit","element","ref","spinnerSlotContainer","fetching","error","forcedScrolling","debouncedLoad","notScrolledContentBeforeLoad","prevScrollTop","scrollTargetElement","computed","target","document","querySelector","value","parentElement","body","addScrollListener","removeScrollListener","handler","addEventListener","passive","removeEventListener","onMounted","style","overflowY","scrollTop","scrollHeight","onBeforeUnmount","computeColor","useColor","spinnerColor","spinnerHeight","offsetHeight","computedOffset","stop","resume","onLoad","clientHeight","scrollDelta","then","finishLoading","catch","onError","forceSetScrollTopToTarget","updateTargetElementScrollTop","isScrolledUp","isSpinnerHidden","stopErrorDisplay","sleep","watch","immediate","class","j","_createBlock","_ctx","_createElementVNode","_renderSlot","_createVNode","size","thickness","color","indeterminate","_hoisted_1","_","S","withConfigTransport","VaInfiniteScroll"],"sources":["../../src/components/va-infinite-scroll/VaInfiniteScroll.vue","../../src/components/va-infinite-scroll/hooks/useScroll.ts","../../src/components/va-infinite-scroll/VaInfiniteScroll.vue?vue&type=template&id=b399cd12&lang.js","../../src/components/va-infinite-scroll/index.ts"],"sourcesContent":["<template>\n  <component\n    :is=\"$props.tag\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    ref=\"element\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n      ref=\"spinnerSlotContainer\"\n    >\n      <slot\n        name=\"loading\"\n        v-if=\"!$props.disabled\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport debounce from 'lodash/debounce'\nimport { computed, defineComponent, ref, watch } from 'vue'\n\nimport { sleep } from '../../services/utils'\nimport { useColor } from '../../composables/useColor'\nimport { useScroll } from './hooks/useScroll'\nimport { VaProgressCircle } from '../va-progress-circle'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: [Element, String], default: null },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = ref<HTMLElement>()\n    const spinnerSlotContainer = ref<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { computeColor } = useColor(props)\n\n    const spinnerColor = computed(() => {\n      return error.value ? computeColor('danger') : computeColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n","import { Ref, onMounted, onBeforeUnmount } from 'vue'\n\ninterface ScrollTargetProps {\n  scrollTarget: Element | string;\n  disabled: boolean;\n  reverse: boolean;\n}\n\nexport const useScroll = (\n  props: ScrollTargetProps,\n  element: Ref<HTMLElement | undefined>,\n  handler: Ref<any>,\n) => {\n  const addScrollListener = () => {\n    element.value?.addEventListener(\n      'scroll',\n      handler.value,\n      { passive: true },\n    )\n  }\n\n  const removeScrollListener = () => {\n    element.value?.removeEventListener(\n      'scroll',\n      handler.value,\n    )\n  }\n\n  onMounted(() => {\n    if (!element.value) { return }\n\n    element.value.style.overflowY = 'scroll'\n\n    if (props.reverse) {\n      element.value.scrollTop = element.value.scrollHeight\n    }\n\n    addScrollListener()\n  })\n\n  onBeforeUnmount(removeScrollListener)\n\n  return {\n    addScrollListener,\n    removeScrollListener,\n  }\n}\n","<template>\n  <component\n    :is=\"$props.tag\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    ref=\"element\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n      ref=\"spinnerSlotContainer\"\n    >\n      <slot\n        name=\"loading\"\n        v-if=\"!$props.disabled\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport debounce from 'lodash/debounce'\nimport { computed, defineComponent, ref, watch } from 'vue'\n\nimport { sleep } from '../../services/utils'\nimport { useColor } from '../../composables/useColor'\nimport { useScroll } from './hooks/useScroll'\nimport { VaProgressCircle } from '../va-progress-circle'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: [Element, String], default: null },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = ref<HTMLElement>()\n    const spinnerSlotContainer = ref<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { computeColor } = useColor(props)\n\n    const spinnerColor = computed(() => {\n      return error.value ? computeColor('danger') : computeColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport VaInfiniteScroll from './VaInfiniteScroll.vue'\n\nexport default withConfigTransport(VaInfiniteScroll)\n"]},"metadata":{},"sourceType":"module"}