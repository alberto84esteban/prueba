{"ast":null,"code":"import { computed as e, ref as t, watch as u } from \"vue\";\n\nfunction useSyncProp(o, r, v, i) {\n  if (void 0 === i) return [e({\n    set(e) {\n      v(`update:${o}`, e);\n    },\n\n    get: () => r[o]\n  })];\n  const n = r[o],\n        a = t(void 0 === n ? i : n);\n  return u(() => r[o], e => {\n    void 0 !== e && (a.value = e);\n  }), [e({\n    set(e) {\n      a.value = e, v(`update:${o}`, e);\n    },\n\n    get: () => void 0 === r[o] ? a.value : r[o]\n  })];\n}\n\nexport { useSyncProp as u };","map":{"version":3,"mappings":";;SAkBgBA,YAObC,GAAoBC,GAAcC,GAAYC;AAC/C,WAAqBC,CAArB,KAAID,CAAJ,EACE,OAAO,CACLE,EAAsB;AACpBC,QAAKC,CAALD,EAAKC;AACHL,QAAK,UAAUF,GAAfE,EAA2BK,CAA3BL;AAA2BK,KAFT;;AAIpBC,SAAG,MACMP,EAAMD,CAANC;AALW,GAAtBI,CADK,CAAP;AAYF,QAAMI,IAAeR,EAAMD,CAANC,CAArB;AAAA,QACMS,IAAgBC,OAAqBP,CAArBO,KAAIF,CAAJE,GAAiCR,CAAjCQ,GAAgDF,CAAhDE,CADtB;AASA,SANAC,EAAM,MAAMX,EAAMD,CAANC,CAAZW,EAA8BC;AAAAA,SACbT,CADaS,KACxBA,CADwBA,KAG5BH,EAAcH,KAAdG,GAAsBG,CAHMA;AAGNA,GAHxBD,GAMO,CACLP,EAAsB;AACpBC,QAAKC,CAALD,EAAKC;AACHG,QAAcH,KAAdG,GAAsBH,CAAtBG,EACAR,EAAK,UAAUF,GAAfE,EAA2BK,CAA3BL,CADAQ;AAC2BH,KAHT;;AAKpBC,SAAG,WAC2BJ,CAD3B,KACOH,EAAMD,CAANC,CADP,GACuCS,EAAcH,KADrD,GAC6DN,EAAMD,CAANC;AAN5C,GAAtBI,CADK,CAAP;AAO0EL;;AAAAA","names":["useSyncProp","propName","props","emit","defaultValue","undefined","computed","set","value","get","currentValue","statefulValue","ref","watch","newVal"],"sources":["../../src/composables/useSyncProp.ts"],"sourcesContent":["import { ref, computed, watch } from 'vue'\n\n/**\n * Returns computed that emits update:${propName} on edit.\n *\n * @tutorial\n * ```\n * const [prop] = useSyncProp('name', props, emit)\n *\n * prop.value = 'New name'\n *\n * $nextTick(() => console.log(prop.value)) // 'New name'\n * ```\n *\n * @notice\n * Be careful, that property is not updating in current render\n * cycle. Be sure to use $nextTick if you need to use this property after change.\n */\nexport function useSyncProp<\n  T,\n  PropName extends string,\n  Props extends { [key in PropName]?: T },\n  Emit extends (event: any, newValue: Props[PropName]) => any,\n  DefaultValue extends Props[PropName],\n  ReturnValue extends DefaultValue extends undefined ? Props[PropName] : NonNullable<Props[PropName]>\n> (propName: PropName, props: Props, emit: Emit, defaultValue?: DefaultValue) {\n  if (defaultValue === undefined) {\n    return [\n      computed<ReturnValue>({\n        set (value: ReturnValue) {\n          emit(`update:${propName}`, value)\n        },\n        get () {\n          return props[propName] as ReturnValue\n        },\n      }),\n    ]\n  }\n\n  const currentValue = props[propName]\n  const statefulValue = ref(currentValue === undefined ? defaultValue : currentValue)\n\n  watch(() => props[propName], (newVal) => {\n    if (newVal === undefined) { return }\n\n    statefulValue.value = newVal as ReturnValue\n  })\n\n  return [\n    computed<ReturnValue>({\n      set (value: ReturnValue) {\n        statefulValue.value = value as ReturnValue\n        emit(`update:${propName}`, value)\n      },\n      get (): ReturnValue {\n        return (props[propName] === undefined ? statefulValue.value : props[propName]) as ReturnValue\n      },\n    }),\n  ]\n}\n"]},"metadata":{},"sourceType":"module"}