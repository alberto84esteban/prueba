{"ast":null,"code":"import { w as o } from \"./withConfigTransport.js\";\nimport { defineComponent as a, ref as t, provide as e, onMounted as l, inject as i, nextTick as r, onUnmounted as s, openBlock as n, createBlock as v, resolveDynamicComponent as u, withCtx as d, renderSlot as f } from \"vue\";\nimport { F as m } from \"./consts.js\";\nimport { s as c } from \"./style-inject.es.js\";\nimport \"./VaConfig.js\";\n\nconst isVaForm = o => !!o.focusInvalid;\n\nvar h = a({\n  name: \"VaForm\",\n  emits: [\"validation\"],\n  props: {\n    autofocus: {\n      type: Boolean,\n      default: !1\n    },\n    tag: {\n      type: String,\n      default: \"div\"\n    }\n  },\n\n  setup(o, {\n    emit: a\n  }) {\n    const n = t([]),\n          parentFormProvider = () => i(m, void 0);\n\n    e(m, {\n      onChildMounted: o => childMountedHandler(o),\n      onChildUnmounted: o => childUnmountedHandler(o)\n    });\n\n    const childMountedHandler = o => {\n      n.value.push(o);\n    },\n          childUnmountedHandler = o => {\n      n.value = n.value.filter(a => a !== o);\n    },\n          focus = () => {\n      var o;\n      null === (o = n.value.find(({\n        focus: o\n      }) => o)) || void 0 === o || o.focus();\n    },\n          v = {\n      reset: () => {\n        n.value.filter(({\n          reset: o\n        }) => o).forEach(o => {\n          o.reset();\n        });\n      },\n      resetValidation: () => {\n        n.value.filter(({\n          resetValidation: o\n        }) => o).forEach(o => {\n          o.resetValidation();\n        });\n      },\n      focus: focus,\n      focusInvalid: () => {\n        const o = n.value.find(o => !isVaForm(o) && o.hasError());\n        o ? o.focus() : n.value.forEach(o => isVaForm(o) && o.focusInvalid());\n      },\n      validate: () => {\n        const o = n.value.filter(({\n          validate: o\n        }) => o).map(o => o.validate()).every(o => o);\n        return a(\"validation\", o), o;\n      }\n    };\n\n    return l(() => {\n      var a, t;\n      null === (t = null === (a = parentFormProvider()) || void 0 === a ? void 0 : a.onChildMounted) || void 0 === t || t.call(a, v), o.autofocus && r(focus);\n    }), s(() => {\n      var o, a;\n      null === (a = null === (o = parentFormProvider()) || void 0 === o ? void 0 : o.onChildUnmounted) || void 0 === a || a.call(o, v);\n    }), v;\n  },\n\n  methods: {\n    reset() {\n      var o;\n      null === (o = this.form) || void 0 === o || o.reset();\n    },\n\n    resetValidation() {\n      var o;\n      null === (o = this.form) || void 0 === o || o.resetValidation();\n    },\n\n    focus() {\n      var o;\n      null === (o = this.form) || void 0 === o || o.focus();\n    },\n\n    focusInvalid() {\n      var o;\n      null === (o = this.form) || void 0 === o || o.focusInvalid();\n    },\n\n    validate() {\n      var o;\n      null === (o = this.form) || void 0 === o || o.validate();\n    }\n\n  }\n});\nc(\".va-form{font-family:var(--va-font-family)}\"), h.render = function render(o, a, t, e, l, i) {\n  return n(), v(u(o.tag), {\n    ref: \"form\",\n    class: \"va-form\"\n  }, {\n    default: d(() => [f(o.$slots, \"default\")]),\n    _: 3\n  }, 512);\n}, h.__file = \"src/components/va-form/VaForm.vue\";\nvar p = o(h);\nexport { p as default };","map":{"version":3,"mappings":"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","names":["isVaForm","value","focusInvalid","defineComponent","name","emits","props","autofocus","type","Boolean","default","tag","String","setup","emit","nestedFormElements","ref","parentFormProvider","inject","FormServiceKey","undefined","provide","onChildMounted","child","childMountedHandler","onChildUnmounted","removableChild","childUnmountedHandler","push","filter","focus","find","publicMethods","reset","forEach","item","resetValidation","invalidComponent","hasError","validate","formValid","map","every","isValid","onMounted","nextTick","onUnmounted","methods","this","form","_createBlock","_ctx","class","_renderSlot","withConfigTransport","VaForm"],"sources":["../../src/components/va-form/VaForm.vue","../../src/components/va-form/VaForm.vue?vue&type=template&id=848ce870&lang.js","../../src/components/va-form/index.ts"],"sourcesContent":["<template>\n  <component\n    ref=\"form\"\n    class=\"va-form\"\n    :is=\"tag\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  PropType,\n  ref,\n  Ref,\n  onMounted,\n  onUnmounted,\n  nextTick,\n  provide,\n  inject,\n} from 'vue'\n\nimport { FormServiceKey, FormChild, Form } from './consts'\n\nconst isVaForm = (value: any): value is Form => !!value.focusInvalid\n\nexport default defineComponent({\n  name: 'VaForm',\n  emits: ['validation'],\n  props: {\n    autofocus: { type: Boolean as PropType<boolean>, default: false },\n    tag: { type: String as PropType<string>, default: 'div' },\n  },\n\n  setup (props, { emit }) {\n    const nestedFormElements: Ref<(FormChild | Form)[]> = ref([])\n\n    const parentFormProvider = () => inject(FormServiceKey, undefined)\n\n    provide(FormServiceKey, {\n      onChildMounted: (child: FormChild | Form) => childMountedHandler(child),\n      onChildUnmounted: (removableChild: FormChild | Form) => childUnmountedHandler(removableChild),\n    })\n\n    const childMountedHandler = (child: FormChild | Form) => {\n      nestedFormElements.value.push(child)\n    }\n\n    const childUnmountedHandler = (removableChild: FormChild | Form) => {\n      nestedFormElements.value = nestedFormElements.value.filter(child => child !== removableChild)\n    }\n\n    /** @public */\n    const reset = () => {\n      nestedFormElements.value\n        .filter(({ reset }) => reset)\n        .forEach((item) => { item.reset() })\n    }\n\n    const resetValidation = () => {\n      nestedFormElements.value\n        .filter(({ resetValidation }) => resetValidation)\n        .forEach((item: any) => { item.resetValidation() })\n    }\n\n    const focus = () => { nestedFormElements.value.find(({ focus }) => focus)?.focus() }\n\n    const focusInvalid = () => {\n      const invalidComponent = nestedFormElements.value\n        .find((item) => !isVaForm(item) && item.hasError())\n\n      if (invalidComponent) {\n        invalidComponent.focus()\n      } else {\n        nestedFormElements.value\n          .forEach(item => isVaForm(item) && item.focusInvalid())\n      }\n    }\n\n    // validation for every nested child\n    const validate = () => { // NOTE: temporarily synchronous validation\n      const formValid = nestedFormElements.value\n        .filter(({ validate }) => validate)\n        .map((child) => child.validate()) // more readable than with 'forEach'\n        .every((isValid) => isValid)\n\n      emit('validation', formValid)\n\n      return formValid\n    }\n\n    const publicMethods: Form = {\n      reset,\n      resetValidation,\n      focus,\n      focusInvalid,\n      validate,\n    }\n\n    onMounted(() => {\n      parentFormProvider()?.onChildMounted?.(publicMethods)\n\n      if (props.autofocus) { nextTick(focus) }\n    })\n\n    onUnmounted(() => {\n      parentFormProvider()?.onChildUnmounted?.(publicMethods)\n    })\n\n    return publicMethods\n  },\n\n  // we will use this while we have 'withConfigTransport' and problem with 'expose' method in 'setup' func\n  methods: {\n    reset () { (this as any).form?.reset() },\n    resetValidation () { (this as any).form?.resetValidation() },\n    focus () { (this as any).form?.focus() },\n    focusInvalid () { (this as any).form?.focusInvalid() },\n    validate () { (this as any).form?.validate() },\n  },\n})\n</script>\n\n<style lang='scss'>\n.va-form {\n  font-family: var(--va-font-family);\n}\n</style>\n","<template>\n  <component\n    ref=\"form\"\n    class=\"va-form\"\n    :is=\"tag\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  PropType,\n  ref,\n  Ref,\n  onMounted,\n  onUnmounted,\n  nextTick,\n  provide,\n  inject,\n} from 'vue'\n\nimport { FormServiceKey, FormChild, Form } from './consts'\n\nconst isVaForm = (value: any): value is Form => !!value.focusInvalid\n\nexport default defineComponent({\n  name: 'VaForm',\n  emits: ['validation'],\n  props: {\n    autofocus: { type: Boolean as PropType<boolean>, default: false },\n    tag: { type: String as PropType<string>, default: 'div' },\n  },\n\n  setup (props, { emit }) {\n    const nestedFormElements: Ref<(FormChild | Form)[]> = ref([])\n\n    const parentFormProvider = () => inject(FormServiceKey, undefined)\n\n    provide(FormServiceKey, {\n      onChildMounted: (child: FormChild | Form) => childMountedHandler(child),\n      onChildUnmounted: (removableChild: FormChild | Form) => childUnmountedHandler(removableChild),\n    })\n\n    const childMountedHandler = (child: FormChild | Form) => {\n      nestedFormElements.value.push(child)\n    }\n\n    const childUnmountedHandler = (removableChild: FormChild | Form) => {\n      nestedFormElements.value = nestedFormElements.value.filter(child => child !== removableChild)\n    }\n\n    /** @public */\n    const reset = () => {\n      nestedFormElements.value\n        .filter(({ reset }) => reset)\n        .forEach((item) => { item.reset() })\n    }\n\n    const resetValidation = () => {\n      nestedFormElements.value\n        .filter(({ resetValidation }) => resetValidation)\n        .forEach((item: any) => { item.resetValidation() })\n    }\n\n    const focus = () => { nestedFormElements.value.find(({ focus }) => focus)?.focus() }\n\n    const focusInvalid = () => {\n      const invalidComponent = nestedFormElements.value\n        .find((item) => !isVaForm(item) && item.hasError())\n\n      if (invalidComponent) {\n        invalidComponent.focus()\n      } else {\n        nestedFormElements.value\n          .forEach(item => isVaForm(item) && item.focusInvalid())\n      }\n    }\n\n    // validation for every nested child\n    const validate = () => { // NOTE: temporarily synchronous validation\n      const formValid = nestedFormElements.value\n        .filter(({ validate }) => validate)\n        .map((child) => child.validate()) // more readable than with 'forEach'\n        .every((isValid) => isValid)\n\n      emit('validation', formValid)\n\n      return formValid\n    }\n\n    const publicMethods: Form = {\n      reset,\n      resetValidation,\n      focus,\n      focusInvalid,\n      validate,\n    }\n\n    onMounted(() => {\n      parentFormProvider()?.onChildMounted?.(publicMethods)\n\n      if (props.autofocus) { nextTick(focus) }\n    })\n\n    onUnmounted(() => {\n      parentFormProvider()?.onChildUnmounted?.(publicMethods)\n    })\n\n    return publicMethods\n  },\n\n  // we will use this while we have 'withConfigTransport' and problem with 'expose' method in 'setup' func\n  methods: {\n    reset () { (this as any).form?.reset() },\n    resetValidation () { (this as any).form?.resetValidation() },\n    focus () { (this as any).form?.focus() },\n    focusInvalid () { (this as any).form?.focusInvalid() },\n    validate () { (this as any).form?.validate() },\n  },\n})\n</script>\n\n<style lang='scss'>\n.va-form {\n  font-family: var(--va-font-family);\n}\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport VaForm from './VaForm.vue'\n\nexport default withConfigTransport(VaForm)\n"]},"metadata":{},"sourceType":"module"}