{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport { defineComponent as e, computed as n, openBlock as t, createBlock as r, resolveDynamicComponent as o, mergeProps as a, withCtx as i, renderSlot as s, createTextVNode as c, toDisplayString as l } from \"vue\";\nimport { i as u, b as f, _ as v, t as m, d as p, e as g, f as d, h, j as y, k as $, l as b, n as w, g as C, o as z } from \"./withConfigTransport.js\";\nimport { f as S } from \"./flatten.js\";\nimport { u as j } from \"./color-config.js\";\nimport { u as k, a as x } from \"./useSize.js\";\nimport { s as E } from \"./style-inject.es.js\";\nvar R = u,\n    I = f,\n    _ = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    A = /^\\w*$/;\n\nvar T = function isKey$1(e, n) {\n  if (R(e)) return !1;\n  var t = typeof e;\n  return !(\"number\" != t && \"symbol\" != t && \"boolean\" != t && null != e && !I(e)) || A.test(e) || !_.test(e) || null != n && e in Object(n);\n},\n    F = v;\n\nfunction memoize$1(e, n) {\n  if (\"function\" != typeof e || null != n && \"function\" != typeof n) throw new TypeError(\"Expected a function\");\n\n  var memoized = function () {\n    var t = arguments,\n        r = n ? n.apply(this, t) : t[0],\n        o = memoized.cache;\n    if (o.has(r)) return o.get(r);\n    var a = e.apply(this, t);\n    return memoized.cache = o.set(r, a) || o, a;\n  };\n\n  return memoized.cache = new (memoize$1.Cache || F)(), memoized;\n}\n\nmemoize$1.Cache = F;\nvar O = memoize$1;\n\nvar P = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n    B = /\\\\(\\\\)?/g,\n    K = function memoizeCapped$1(e) {\n  var n = O(e, function (e) {\n    return 500 === t.size && t.clear(), e;\n  }),\n      t = n.cache;\n  return n;\n}(function (e) {\n  var n = [];\n  return 46 === e.charCodeAt(0) && n.push(\"\"), e.replace(P, function (e, t, r, o) {\n    n.push(r ? o.replace(B, \"$1\") : t || e);\n  }), n;\n}),\n    U = u,\n    V = T,\n    G = K,\n    N = m;\n\nvar q = function castPath$3(e, n) {\n  return U(e) ? e : V(e, n) ? [e] : G(N(e));\n};\n\nvar D = f;\n\nvar H = function toKey$2(e) {\n  if (\"string\" == typeof e || D(e)) return e;\n  var n = e + \"\";\n  return \"0\" == n && 1 / e == -Infinity ? \"-0\" : n;\n},\n    J = q,\n    L = H;\n\nvar M = function baseGet$1(e, n) {\n  for (var t = 0, r = (n = J(n, e)).length; null != e && t < r;) e = e[L(n[t++])];\n\n  return t && t == r ? e : void 0;\n},\n    Q = M,\n    W = p;\n\nvar X = q,\n    Y = function last$1(e) {\n  var n = null == e ? 0 : e.length;\n  return n ? e[n - 1] : void 0;\n},\n    Z = function parent$1(e, n) {\n  return n.length < 2 ? e : Q(e, W(n, 0, -1));\n},\n    ee = H;\n\nvar ne = g;\nvar te = S,\n    re = d,\n    oe = h;\n\nvar ae = function flatRest$1(e) {\n  return oe(re(e, void 0, te), e + \"\");\n},\n    ie = y,\n    se = w,\n    ce = function baseUnset$1(e, n) {\n  return n = X(n, e), null == (e = Z(e, n)) || delete e[ee(Y(n))];\n},\n    le = q,\n    ue = $,\n    fe = function customOmitClone$1(e) {\n  return ne(e) ? void 0 : e;\n},\n    ve = b,\n    me = ae(function (e, n) {\n  var t = {};\n  if (null == e) return t;\n  var r = !1;\n  n = ie(n, function (n) {\n    return n = le(n, e), r || (r = n.length > 1), n;\n  }), ue(e, ve(e), t), r && (t = se(t, 7, fe));\n\n  for (var o = n.length; o--;) ce(t, n[o]);\n\n  return t;\n});\n\nconst regexGroupsValues = (e, n) => {\n  if (\"string\" != typeof n && n.global) return [...e.matchAll(n)].map(e => e.slice(1));\n  const t = e.match(n) || [];\n  return t ? t.length > 1 ? t.slice(1) : t : [];\n},\n      pe = /{[^}]*}/g,\n      dynamicSegmentStringToRegex = e => e.replace(pe, \"(.*)\"),\n      dynamicSegments = (e, n) => {\n  const t = (e => (e.match(pe) || []).map(e => e.replace(/{|}/g, \"\")))(n),\n        r = ((e, n) => regexGroupsValues(e, dynamicSegmentStringToRegex(n)))(e, n);\n\n  return t.reduce((e, n, t) => ({ ...e,\n    [n]: r[t]\n  }), {});\n},\n      isIconConfigurationString = e => \"string\" == typeof e.name,\n      isIconConfigurationRegex = e => e.name instanceof RegExp,\n      isMatchConfiguration = (e, n) => {\n  return isIconConfigurationString(n) ? ((e, n) => {\n    const t = dynamicSegmentStringToRegex(n);\n    return ((e, n) => (e.match(n) || [])[0] === e)(e, new RegExp(t));\n  })(e, n.name) : !!isIconConfigurationRegex(n) && (t = e, n.name.test(t));\n  var t;\n},\n      resolveIconConfiguration = (e, n) => {\n  if (isIconConfigurationString(n)) return ((e, n) => {\n    const t = dynamicSegments(e, n.name);\n    return n.resolve && n.resolve(t);\n  })(e, n);\n  if (isIconConfigurationRegex(n)) return ((e, n) => {\n    if (n.name.global) throw new Error(`Bad icon config with name ${n.name}. Please, don't use global regex as name.`);\n    const t = regexGroupsValues(e, n.name);\n    return n.resolveFromRegex && n.resolveFromRegex(...t);\n  })(e, n);\n  throw Error(\"Unknown icon config\");\n},\n      findIconConfiguration = (e, n, t = []) => {\n  if (!e) return;\n\n  const r = ((e, n, t = []) => {\n    const r = n.find(n => !t.includes(n.name.toString()) && isMatchConfiguration(e, n));\n    if (!r) throw new Error(`Can not find icon config from ${e}. Please provide default config.`);\n    return r;\n  })(e, n, t),\n        o = z(resolveIconConfiguration(e, r), r);\n\n  return t = [...t, r.name.toString()], z(findIconConfiguration(o.to, n, t), o);\n},\n      getIconConfiguration = (e, n = (() => C().icons || [])()) => {\n  const t = findIconConfiguration(e, n);\n  return void 0 === t ? {} : (e => {\n    const n = e;\n    return [\"name\", \"to\", \"resolve\", \"resolveFromRegex\"].forEach(e => {\n      delete n[e];\n    }), n;\n  })(t);\n},\n      useIcons = e => ({\n  getIcon: e => getIconConfiguration(e)\n});\n\nvar ge = e({\n  name: \"VaIcon\",\n  props: { ...k,\n    name: {\n      type: String,\n      default: \"\"\n    },\n    tag: {\n      type: String\n    },\n    component: {\n      type: Object\n    },\n    color: {\n      type: String\n    },\n    rotation: {\n      type: [String, Number]\n    },\n    spin: {\n      type: [String, Boolean]\n    },\n    flip: {\n      type: String,\n      default: \"off\",\n      validator: e => [\"off\", \"horizontal\", \"vertical\", \"both\"].includes(e)\n    }\n  },\n\n  setup(e, {\n    attrs: t\n  }) {\n    const {\n      getColor: r\n    } = j(),\n          {\n      sizeComputed: o\n    } = x(e),\n          {\n      getIcon: a\n    } = useIcons(),\n          i = n(() => a(e.name)),\n          s = n(() => e.component || e.tag || i.value.component || i.value.tag || \"i\"),\n          c = n(() => ({ ...i.value.attrs,\n      ...me(t, [\"class\"])\n    })),\n          getSpinClass = e => {\n      if (e) return \"counter-clockwise\" === e ? \"va-icon--spin-reverse\" : \"va-icon--spin\";\n    },\n          l = n(() => {\n      var n;\n      return [i.value.class, getSpinClass(null !== (n = e.spin) && void 0 !== n ? n : i.value.spin)];\n    }),\n          u = n(() => {\n      const n = e.rotation ? `rotate(${e.rotation}deg)` : \"\",\n            t = \"vertical\" === e.flip || \"both\" === e.flip ? -1 : 1,\n            r = \"horizontal\" === e.flip || \"both\" === e.flip ? -1 : 1;\n      return `${\"off\" === e.flip ? \"\" : `scale(${t}, ${r})`} ${n}`.trim();\n    }),\n          f = n(() => ({\n      transform: u.value,\n      cursor: t.onClick ? \"pointer\" : null,\n      color: e.color ? r(e.color) : i.value.color,\n      fontSize: o.value\n    }));\n\n    return {\n      iconConfig: i,\n      computedTag: s,\n      computedAttrs: c,\n      computedClass: l,\n      computedStyle: f\n    };\n  }\n\n});\nE(\":root{--va-icon-vertical-align:middle;--va-icon-user-select:none}.va-icon{-webkit-user-select:var(--va-icon-user-select);-moz-user-select:var(--va-icon-user-select);-ms-user-select:var(--va-icon-user-select);user-select:var(--va-icon-user-select);vertical-align:var(--va-icon-vertical-align)}.va-icon.va-icon{font-style:normal}.va-icon--spin,.va-icon--spin-reverse{-webkit-animation:va-icon--spin-animation 1.5s linear infinite;animation:va-icon--spin-animation 1.5s linear infinite}.va-icon--spin-reverse{animation-direction:reverse}@-webkit-keyframes va-icon--spin-animation{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@keyframes va-icon--spin-animation{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}\"), ge.render = function render(e, n, u, f, v, m) {\n  return t(), r(o(e.computedTag), a(e.computedAttrs, {\n    \"aria-hidden\": \"true\",\n    notranslate: \"\",\n    class: [\"va-icon\", e.computedClass],\n    style: e.computedStyle\n  }), {\n    default: i(() => [s(e.$slots, \"default\", {}, () => [c(l(e.iconConfig.content), 1)])]),\n    _: 3\n  }, 16, [\"class\", \"style\"]);\n}, ge.__file = \"src/components/va-icon/VaIcon.vue\";\nexport { q as _, H as a, M as b, ae as c, me as o, ge as s, useIcons as u };","map":{"version":3,"mappings":"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","names":["isArray","require$$0","isSymbol","require$$1","reIsDeepProp","reIsPlainProp","_isKey","isKey","value","object","type","test","Object","MapCache","memoize","func","resolver","TypeError","memoized","args","arguments","key","apply","this","cache","has","get","result","set","Cache","rePropName","reEscapeChar","stringToPath","memoizeCapped","size","clear","string","charCodeAt","push","replace","match","number","quote","subString","toString","require$$3","_castPath","castPath","_toKey","toKey","Infinity","_baseGet","baseGet","path","index","length","undefined","baseSlice","last","array","parent","isPlainObject","flatten","overRest","setToString","require$$2","_flatRest","flatRest","arrayMap","baseClone","baseUnset","copyObject","require$$4","customOmitClone","getAllKeysIn","require$$7","require$$6","paths","isDeep","CLONE_DEEP_FLAG","regexGroupsValues","str","regex","global","matchAll","map","g","slice","dynamicSegmentRegex","dynamicSegmentStringToRegex","template","dynamicSegments","params","values","reduce","acc","paramValue","i","isIconConfigurationString","config","name","isIconConfigurationRegex","RegExp","isMatchConfiguration","iconName","iconConfiguration","templateRegex","resolveIconConfiguration","resolve","iconConfig","Error","resolveFromRegex","findIconConfiguration","globalIconConfig","namesToIgnore","matchedIconConfiguration","matchedConfig","find","includes","resolvedIconConfiguration","merge","to","getIconConfiguration","getGlobalConfig","icons","getIconConfig","configuration","forEach","useIcons","props","getIcon","defineComponent","useSizeProps","String","default","tag","component","color","rotation","Number","spin","Boolean","flip","validator","setup","attrs","getColor","useColors","sizeComputed","useSize","computed","computedTag","computedAttrs","omit","getSpinClass","computedClass","class","transformStyle","flipY","flipX","trim","computedStyle","transform","cursor","onClick","fontSize","_createBlock","_ctx","_mergeProps","notranslate","style","content"],"sources":["../../../../node_modules/lodash/_isKey.js","../../../../node_modules/lodash/memoize.js","../../../../node_modules/lodash/_memoizeCapped.js","../../../../node_modules/lodash/_stringToPath.js","../../../../node_modules/lodash/_castPath.js","../../../../node_modules/lodash/_toKey.js","../../../../node_modules/lodash/_baseGet.js","../../../../node_modules/lodash/_parent.js","../../../../node_modules/lodash/_baseUnset.js","../../../../node_modules/lodash/last.js","../../../../node_modules/lodash/_customOmitClone.js","../../../../node_modules/lodash/_flatRest.js","../../../../node_modules/lodash/omit.js","../../src/services/icon-config/utils/regex.ts","../../src/services/icon-config/utils/dynamic-segment.ts","../../src/services/icon-config/types.ts","../../src/services/icon-config/icon-helpers.ts","../../src/services/icon-config/icon-config-hooks.ts","../../src/components/va-icon/VaIcon.vue","../../src/components/va-icon/VaIcon.vue?vue&type=template&id=28d73628&lang.js"],"sourcesContent":["var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var baseGet = require('./_baseGet'),\n    baseSlice = require('./_baseSlice');\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\nmodule.exports = parent;\n","var castPath = require('./_castPath'),\n    last = require('./last'),\n    parent = require('./_parent'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = castPath(path, object);\n  object = parent(object, path);\n  return object == null || delete object[toKey(last(path))];\n}\n\nmodule.exports = baseUnset;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n","var isPlainObject = require('./isPlainObject');\n\n/**\n * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n * objects.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {string} key The key of the property to inspect.\n * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n */\nfunction customOmitClone(value) {\n  return isPlainObject(value) ? undefined : value;\n}\n\nmodule.exports = customOmitClone;\n","var flatten = require('./flatten'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nmodule.exports = flatRest;\n","var arrayMap = require('./_arrayMap'),\n    baseClone = require('./_baseClone'),\n    baseUnset = require('./_baseUnset'),\n    castPath = require('./_castPath'),\n    copyObject = require('./_copyObject'),\n    customOmitClone = require('./_customOmitClone'),\n    flatRest = require('./_flatRest'),\n    getAllKeysIn = require('./_getAllKeysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable property paths of `object` that are not omitted.\n *\n * **Note:** This method is considerably slower than `_.pick`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to omit.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omit(object, ['a', 'c']);\n * // => { 'b': '2' }\n */\nvar omit = flatRest(function(object, paths) {\n  var result = {};\n  if (object == null) {\n    return result;\n  }\n  var isDeep = false;\n  paths = arrayMap(paths, function(path) {\n    path = castPath(path, object);\n    isDeep || (isDeep = path.length > 1);\n    return path;\n  });\n  copyObject(object, getAllKeysIn(object), result);\n  if (isDeep) {\n    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n  }\n  var length = paths.length;\n  while (length--) {\n    baseUnset(result, paths[length]);\n  }\n  return result;\n});\n\nmodule.exports = omit;\n","export const isMatchRegex = (str: string, regex: RegExp) => {\n  return regex.test(str)\n}\n\n/**\n * Return values from regex groups\n * @example\n * ```\n * \"fa-phone-o\", /fa-(.*)-(.*)/ -> [\"phone\", \"o\"]\n * \"any string\", /(.*)/ -> [\"any string\"]\n * \"global regex test\", /global (regex) (test)/g -> [['regex', 'test']]\n * ```\n */\nexport const regexGroupsValues = (str: string, regex: RegExp | string): string[] | string[][] => {\n  if (typeof regex !== 'string' && regex.global) {\n    // Global regex can return multiple matches array. So we need to map this all matches and remove non group values.\n    return [...str.matchAll(regex)].map(g => g.slice(1))\n  }\n\n  const match = str.match(regex) || []\n  if (!match) { return [] }\n  /**\n   * If there is groups in result - we need to slice first match\n   * ```\n   * \"test\".match(/(s)/)\n   * > Array [ \"s\", \"s\" ]\n   * ```\n   */\n  if (match.length > 1) { return match.slice(1) }\n\n  return match\n}\n","import { regexGroupsValues } from './regex'\n\nconst dynamicSegmentRegex = /{[^}]*}/g // match {any-thing}, {even with space}\n\n/**\n * Replace {anything} to regex (.*) group\n * @example\n * ```\n * \"fa-{code}\" -> \"fa-(.*)\"\n * \"fa-{code}-{suffix}\" -> \"fa-(.*)-(.*)\"\n * ```\n */\nconst dynamicSegmentStringToRegex = (template: string) => {\n  return template.replace(dynamicSegmentRegex, '(.*)')\n}\n\n/**\n Returns content from string in {}\n @example\n ```\n \"fa-{code}-{suffix}\" -> ['code', 'suffix']\n ```\n */\nconst dynamicSegmentsNames = (template: string) => {\n  return (template.match(dynamicSegmentRegex) || []) // 'fa-{code}-{suffix}' -> ['{code}', '{suffix}']\n    .map((g) => g.replace(/{|}/g, '')) // ['{code}', '{suffix}'] -> ['code', 'suffix']\n}\n\n/**\n * Transform template to regex and returns regex group values\n * @example\n * ```\n * \"fa-clock-o\", \"fa-{code}-{suffix}\" -> [\"clock\", \"o\"]\n * ```\n */\nconst dynamicSegmentsValues = (str: string, template: string) => {\n  return regexGroupsValues(str, dynamicSegmentStringToRegex(template))\n}\n\n/**\n * Returns object with param name from template and match value from str\n * @example\n * ```\n * \"fa-phone\", \"fa-{icon code}\" -> { 'icon code': 'phone' }\n * \"fa4 clock-o\", \"fa4 {icon-code}-{suffix}\" -> { 'icon-code': 'clock', 'suffix': 'o' }\n * \"fa4 clock-o\", \"fa4 {icon-code}\" -> { 'icon-code': 'clock-o' }\n * ```\n */\nexport const dynamicSegments = (str: string, template: string) => {\n  const params = dynamicSegmentsNames(template)\n  const values = dynamicSegmentsValues(str, template)\n\n  return params.reduce((acc, paramValue, i) => ({ ...acc, [paramValue]: values[i] }), {})\n}\n\n/**\n * Returns true if match string equals to input `str`\n * @example\n * ```\n * \"vuestic-home-open\", /vuestic-(.*)-o/ -> false\n * \"vuestic-home-open\", /vuestic-(.*)-open/ -> true\n * ```\n */\nconst strictMatch = (str: string, regex: RegExp) => {\n  return (str.match(regex) || [])[0] === str\n}\n\n/**\n * Returns true if str match template\n * @example\n *  ```\n * \"fa-phone\", \"fa-{icon code}\" -> true\n * \"fa4 clock-o\", \"fa4 {icon-code}-{suffix}\" -> true\n * \"fa4 clock-o\", \"fa4 {icon-code}\" -> false\n * ```\n */\nexport const isMatchDynamicSegments = (str: string, template: string) => {\n  const templateRegex = dynamicSegmentStringToRegex(template)\n  return strictMatch(str, new RegExp(templateRegex))\n}\n","export interface IconProps {\n  attrs?: Record<string, string | ((...args: any[]) => unknown)>\n\n  /** Vue component */\n  component?: any\n  /** Content that will be passed as text inside icon tag or as slot in component */\n  content?: string\n\n  class?: string,\n  tag?: string\n  color?: string\n  rotation?: number | string\n  spin?: 'clockwise' | 'counter-clockwise' | boolean\n  to?: string\n}\n\nexport interface IconConfigurationString extends IconProps {\n  name: string\n  resolve?: ((dynamicSegments: {[dynamicSegment: string]: string }) => IconProps)\n}\n\nexport interface IconConfigurationRegex extends IconProps {\n  name: RegExp\n  // Need a different resolve method name because ts don't understand types\n  resolveFromRegex?: ((...regexGroupValues: string[]) => IconProps)\n}\n\nexport type IconConfiguration = IconConfigurationString | IconConfigurationRegex\n\nexport type IconConfig = IconConfiguration[]\n\nexport const isIconConfigurationString = (config: IconConfiguration): config is IconConfigurationString => {\n  return typeof config.name === 'string'\n}\n\nexport const isIconConfigurationRegex = (config: IconConfiguration): config is IconConfigurationRegex => {\n  return config.name instanceof RegExp\n}\n","import merge from 'lodash/merge'\nimport { getGlobalConfig } from '../global-config/global-config'\nimport { isMatchDynamicSegments, dynamicSegments } from './utils/dynamic-segment'\nimport { isMatchRegex, regexGroupsValues } from './utils/regex'\nimport {\n  IconConfig,\n  IconConfiguration,\n  IconConfigurationString,\n  IconConfigurationRegex,\n  isIconConfigurationString,\n  isIconConfigurationRegex,\n  IconProps,\n} from './types'\n\nconst getIconConfig = (): IconConfig => {\n  return getGlobalConfig().icons || []\n}\n\nconst isMatchConfiguration = (iconName: string, iconConfiguration: IconConfiguration) => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return isMatchDynamicSegments(iconName, iconConfiguration.name)\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return isMatchRegex(iconName, iconConfiguration.name)\n  }\n\n  return false\n}\n\nconst resolveIconConfigurationString = (iconName: string, iconConfiguration: IconConfigurationString) => {\n  const args = dynamicSegments(iconName, iconConfiguration.name)\n  return iconConfiguration.resolve && iconConfiguration.resolve(args)\n}\n\nconst resolveIconConfigurationRegex = (iconName: string, iconConfig: IconConfigurationRegex) => {\n  if (iconConfig.name.global) {\n    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`)\n  }\n  const args = regexGroupsValues(iconName, iconConfig.name) as string[]\n  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args)\n}\n\nconst resolveIconConfiguration = (iconName: string, iconConfiguration: IconConfiguration): IconProps | undefined => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return resolveIconConfigurationString(iconName, iconConfiguration)\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return resolveIconConfigurationRegex(iconName, iconConfiguration)\n  }\n\n  throw Error('Unknown icon config')\n}\n\nconst findMatchedIconConfiguration = (iconName: string, globalIconConfig: IconConfig, namesToIgnore: string[] = []): IconConfiguration => {\n  const matchedConfig = globalIconConfig.find((config) => {\n    if (namesToIgnore.includes(config.name.toString())) { return false }\n\n    return isMatchConfiguration(iconName, config)\n  })\n\n  if (!matchedConfig) { throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`) }\n\n  return matchedConfig\n}\n\nconst findIconConfiguration = (iconName: string | undefined, globalIconConfig: IconConfig, namesToIgnore: string[] = []): IconConfiguration | undefined => {\n  if (!iconName) { return }\n\n  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore)\n  const resolvedIconConfiguration = merge(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration)\n\n  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()]\n\n  return merge(\n    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),\n    resolvedIconConfiguration,\n  )\n}\n\n/** Removes name, to, resolveFromRegex and resolve from IconConfiguration */\nconst iconPropsFromIconConfiguration = (iconConfiguration: IconConfiguration): IconProps => {\n  const junkKeys = ['name', 'to', 'resolve', 'resolveFromRegex']\n\n  const configuration: Record<string, string> = iconConfiguration as any\n  junkKeys.forEach((key) => { delete configuration[key] })\n  return configuration\n}\n\nexport const getIconConfiguration = (name: string, iconConfig: IconConfig = getIconConfig()): IconProps => {\n  const configuration = findIconConfiguration(name, iconConfig)\n\n  if (configuration === undefined) { return {} }\n\n  return iconPropsFromIconConfiguration(configuration)\n}\n","import { getIconConfiguration } from './icon-helpers'\n\nexport const useIcons = (props: any) => {\n  return {\n    // TODO: export here function that can dynamically change icons config\n    getIcon: (name: string) => getIconConfiguration(name),\n  }\n}\n","<template>\n  <component\n    v-bind=\"computedAttrs\"\n    aria-hidden=\"true\"\n    notranslate\n    class=\"va-icon\"\n    :is=\"computedTag\"\n    :class=\"computedClass\"\n    :style=\"computedStyle\"\n  >\n    <slot>{{ iconConfig.content }}</slot>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, computed } from 'vue'\nimport omit from 'lodash/omit'\n\nimport { useColors } from '../../services/color-config/color-config'\nimport { useIcons } from '../../services/icon-config/icon-config'\nimport { useSize, useSizeProps } from '../../composables/useSize'\n\nexport default defineComponent({\n  name: 'VaIcon',\n  props: {\n    ...useSizeProps,\n    name: { type: String as PropType<string>, default: '' },\n    tag: { type: String as PropType<string> },\n    component: { type: Object as PropType<Record<string, any>> },\n    color: { type: String as PropType<string> },\n    rotation: { type: [String, Number] as PropType<number | string> },\n    spin: { type: [String, Boolean] as PropType<string | boolean> },\n    flip: {\n      type: String as PropType<'off' | 'horizontal' | 'vertical' | 'both'>,\n      default: 'off',\n      validator: (value: string) => ['off', 'horizontal', 'vertical', 'both'].includes(value),\n    },\n  },\n  setup (props, { attrs }) {\n    const { getColor } = useColors()\n    const { sizeComputed } = useSize(props)\n    const { getIcon } = useIcons(props)\n\n    const iconConfig = computed(() => getIcon(props.name))\n\n    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || 'i')\n\n    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit(attrs, ['class']) }))\n\n    const getSpinClass = (spin?: string | boolean) => {\n      if (!spin) { return }\n      return spin === 'counter-clockwise' ? 'va-icon--spin-reverse' : 'va-icon--spin'\n    }\n\n    const computedClass = computed(() => [\n      iconConfig.value.class,\n      getSpinClass(props.spin ?? iconConfig.value.spin),\n    ])\n\n    const transformStyle = computed(() => {\n      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : ''\n\n      const flipY = (props.flip === 'vertical' || props.flip === 'both') ? -1 : 1\n      const flipX = (props.flip === 'horizontal' || props.flip === 'both') ? -1 : 1\n      const scale = props.flip === 'off' ? '' : `scale(${flipY}, ${flipX})`\n\n      return `${scale} ${rotation}`.trim()\n    })\n\n    const computedStyle = computed(() => ({\n      transform: transformStyle.value,\n      cursor: attrs.onClick ? 'pointer' : null,\n      color: props.color ? getColor(props.color) : iconConfig.value.color,\n      fontSize: sizeComputed.value,\n    }))\n\n    return {\n      iconConfig,\n      computedTag,\n      computedAttrs,\n      computedClass,\n      computedStyle,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-icon {\n  vertical-align: var(--va-icon-vertical-align);\n  user-select: var(--va-icon-user-select);\n\n  &#{&} {\n    // need 2 classes to make it work\n    font-style: normal;\n  }\n\n  &--spin {\n    animation: va-icon--spin-animation 1500ms linear infinite;\n\n    &-reverse {\n      animation: va-icon--spin-animation 1500ms linear infinite;\n      animation-direction: reverse;\n    }\n  }\n\n  @keyframes va-icon--spin-animation {\n    from {\n      transform: rotate(0deg);\n    }\n\n    to {\n      transform: rotate(360deg);\n    }\n  }\n}\n</style>\n","<template>\n  <component\n    v-bind=\"computedAttrs\"\n    aria-hidden=\"true\"\n    notranslate\n    class=\"va-icon\"\n    :is=\"computedTag\"\n    :class=\"computedClass\"\n    :style=\"computedStyle\"\n  >\n    <slot>{{ iconConfig.content }}</slot>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, computed } from 'vue'\nimport omit from 'lodash/omit'\n\nimport { useColors } from '../../services/color-config/color-config'\nimport { useIcons } from '../../services/icon-config/icon-config'\nimport { useSize, useSizeProps } from '../../composables/useSize'\n\nexport default defineComponent({\n  name: 'VaIcon',\n  props: {\n    ...useSizeProps,\n    name: { type: String as PropType<string>, default: '' },\n    tag: { type: String as PropType<string> },\n    component: { type: Object as PropType<Record<string, any>> },\n    color: { type: String as PropType<string> },\n    rotation: { type: [String, Number] as PropType<number | string> },\n    spin: { type: [String, Boolean] as PropType<string | boolean> },\n    flip: {\n      type: String as PropType<'off' | 'horizontal' | 'vertical' | 'both'>,\n      default: 'off',\n      validator: (value: string) => ['off', 'horizontal', 'vertical', 'both'].includes(value),\n    },\n  },\n  setup (props, { attrs }) {\n    const { getColor } = useColors()\n    const { sizeComputed } = useSize(props)\n    const { getIcon } = useIcons(props)\n\n    const iconConfig = computed(() => getIcon(props.name))\n\n    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || 'i')\n\n    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit(attrs, ['class']) }))\n\n    const getSpinClass = (spin?: string | boolean) => {\n      if (!spin) { return }\n      return spin === 'counter-clockwise' ? 'va-icon--spin-reverse' : 'va-icon--spin'\n    }\n\n    const computedClass = computed(() => [\n      iconConfig.value.class,\n      getSpinClass(props.spin ?? iconConfig.value.spin),\n    ])\n\n    const transformStyle = computed(() => {\n      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : ''\n\n      const flipY = (props.flip === 'vertical' || props.flip === 'both') ? -1 : 1\n      const flipX = (props.flip === 'horizontal' || props.flip === 'both') ? -1 : 1\n      const scale = props.flip === 'off' ? '' : `scale(${flipY}, ${flipX})`\n\n      return `${scale} ${rotation}`.trim()\n    })\n\n    const computedStyle = computed(() => ({\n      transform: transformStyle.value,\n      cursor: attrs.onClick ? 'pointer' : null,\n      color: props.color ? getColor(props.color) : iconConfig.value.color,\n      fontSize: sizeComputed.value,\n    }))\n\n    return {\n      iconConfig,\n      computedTag,\n      computedAttrs,\n      computedClass,\n      computedStyle,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-icon {\n  vertical-align: var(--va-icon-vertical-align);\n  user-select: var(--va-icon-user-select);\n\n  &#{&} {\n    // need 2 classes to make it work\n    font-style: normal;\n  }\n\n  &--spin {\n    animation: va-icon--spin-animation 1500ms linear infinite;\n\n    &-reverse {\n      animation: va-icon--spin-animation 1500ms linear infinite;\n      animation-direction: reverse;\n    }\n  }\n\n  @keyframes va-icon--spin-animation {\n    from {\n      transform: rotate(0deg);\n    }\n\n    to {\n      transform: rotate(360deg);\n    }\n  }\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}