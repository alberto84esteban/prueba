{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { p as t, w as e } from \"./withConfigTransport.js\";\nimport { defineComponent as i, computed as o, ref as n, onBeforeUnmount as f, onMounted as a, nextTick as d, openBlock as s, createElementBlock as r, createElementVNode as l, normalizeStyle as u, renderSlot as c, normalizeClass as p, createCommentVNode as m } from \"vue\";\nimport { d as v } from \"./debounce.js\";\nimport { s as x } from \"./style-inject.es.js\";\nimport \"./VaConfig.js\";\nimport \"./toNumber.js\";\n\nvar g = function noop() {},\n    h = v,\n    w = t;\n\nvar A = function throttle(t, e, i) {\n  var o = !0,\n      n = !0;\n  if (\"function\" != typeof t) throw new TypeError(\"Expected a function\");\n  return w(i) && (o = \"leading\" in i ? !!i.leading : o, n = \"trailing\" in i ? !!i.trailing : n), h(t, e, {\n    leading: o,\n    maxWait: e,\n    trailing: n\n  });\n};\n\nfunction getWindowHeight() {\n  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;\n}\n\nfunction computeAffixedState({\n  coordinates: t,\n  offsetTop: e,\n  offsetBottom: i,\n  target: o\n}) {\n  let n = !1,\n      f = !1;\n  const a = getWindowHeight();\n  if (null != e && a) if (o === window) n = t.top <= e;else {\n    const {\n      top: i\n    } = o.getBoundingClientRect();\n    n = t.top - i <= e;\n  }\n  if (null != i && a) if (o === window) f = t.bottom >= a - i;else {\n    const {\n      bottom: e\n    } = o.getBoundingClientRect();\n    f = e - t.bottom <= i;\n  }\n  return {\n    isTopAffixed: n,\n    isBottomAffixed: f\n  };\n}\n\nfunction handleThrottledEvent(t, e) {\n  const {\n    target: i,\n    element: o,\n    offsetTop: n,\n    offsetBottom: f,\n    setState: a,\n    getState: d,\n    initialPosition: s\n  } = e;\n  let r;\n  const l = !t,\n        u = o.getBoundingClientRect(),\n        c = {\n    offsetBottom: f,\n    offsetTop: n,\n    target: i\n  };\n  r = computeAffixedState(l && s ? {\n    coordinates: s,\n    ...c\n  } : {\n    coordinates: u,\n    ...c\n  });\n  const p = d();\n  !function checkAffixedStateChange(t, e) {\n    return t.isTopAffixed !== e.isTopAffixed || t.isBottomAffixed !== e.isBottomAffixed;\n  }(p, r) ? p.width !== u.width && a({ ...p,\n    width: u.width\n  }) : a({ ...r,\n    width: u.width\n  });\n}\n\nfunction useCaptureDefault(t) {\n  return \"scroll\" === t;\n}\n\nvar B = i({\n  name: \"VaAffix\",\n  emits: [\"change\"],\n  props: {\n    offsetTop: {\n      type: Number,\n      default: void 0\n    },\n    offsetBottom: {\n      type: Number,\n      default: void 0\n    },\n    target: {\n      type: Function,\n      default: () => () => window\n    }\n  },\n\n  setup(t, {\n    emit: e\n  }) {\n    const getTargetElement = () => t.target(),\n          i = o(() => s.value.isTopAffixed || s.value.isBottomAffixed),\n          s = n({\n      isTopAffixed: !1,\n      isBottomAffixed: !1\n    }),\n          getState = () => s.value,\n          setState = t => {\n      s.value = t, e(\"change\", i);\n    },\n          calculateTop = () => {\n      const e = getTargetElement();\n\n      if (void 0 !== t.offsetTop) {\n        if (!(e instanceof Window)) {\n          const {\n            top: i\n          } = e.getBoundingClientRect();\n          return i + t.offsetTop;\n        }\n\n        return t.offsetTop;\n      }\n    },\n          calculateBottom = () => {\n      const e = getTargetElement();\n\n      if (void 0 !== t.offsetBottom) {\n        if (!(e instanceof Window)) {\n          const {\n            bottom: i\n          } = e.getBoundingClientRect(),\n                {\n            borderTopWidth: o,\n            borderBottomWidth: n\n          } = getComputedStyle(e),\n                {\n            offsetHeight: f,\n            clientHeight: a\n          } = e,\n                d = f - a - parseInt(o) - parseInt(n);\n          return getWindowHeight() - (i - t.offsetBottom) + d;\n        }\n\n        return t.offsetBottom;\n      }\n    },\n          convertToPixels = t => {\n      const e = t();\n      return void 0 === e ? void 0 : `${e}px`;\n    },\n          r = o(() => [{\n      \"va-affix--affixed\": i\n    }]),\n          l = o(() => ({\n      top: s.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,\n      bottom: s.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,\n      width: `${s.value.width}px`\n    })),\n          u = n(),\n          c = n(null),\n          throttledEventHandler = (e, i) => {\n      const o = { ...t,\n        initialPosition: u.value,\n        element: c.value,\n        target: getTargetElement(),\n        setState: setState,\n        getState: getState\n      };\n\n      if (e && \"resize\" !== e) {\n        if (i && i.target) {\n          const t = getTargetElement();\n          t === i.target || t instanceof Window ? handleThrottledEvent(e, o) : setState({\n            isBottomAffixed: !1,\n            isTopAffixed: !1\n          });\n        }\n      } else handleThrottledEvent(e, o);\n    };\n\n    let p = g;\n    return f(() => p()), a(() => {\n      var t;\n      u.value = null === (t = c.value) || void 0 === t ? void 0 : t.getBoundingClientRect(), p = function useEventsHandlerWithThrottle(t, {\n        handler: e,\n        useCapture: i = useCaptureDefault,\n        wait: o = 50\n      }) {\n        const n = t.map(t => {\n          const n = A(i => e(t, i), o);\n          return window.addEventListener(t, n, i(t)), () => window.removeEventListener(t, n, i(t));\n        });\n        return () => n.forEach(t => t());\n      }([\"scroll\", \"resize\"], {\n        handler: throttledEventHandler\n      }), d(() => {\n        throttledEventHandler(null);\n      });\n    }), {\n      computedClass: r,\n      computedStyle: l,\n      isAffixed: i,\n      element: c\n    };\n  }\n\n});\nconst T = {\n  ref: \"element\",\n  class: \"va-affix\"\n};\nx(\":root{--va-affix-affixed-z-index:10;--va-affix-affixed-position:fixed}.va-affix{font-family:var(--va-font-family)}.va-affix--affixed{position:var(--va-affix-affixed-position);z-index:var(--va-affix-affixed-z-index)}\"), B.render = function render(t, e, i, o, n, f) {\n  return s(), r(\"div\", T, [l(\"div\", {\n    style: u({\n      visibility: t.isAffixed ? \"hidden\" : \"inherit\"\n    })\n  }, [c(t.$slots, \"default\")], 4), t.isAffixed ? (s(), r(\"div\", {\n    key: 0,\n    class: p(t.computedClass),\n    style: u(t.computedStyle)\n  }, [c(t.$slots, \"default\")], 6)) : m(\"v-if\", !0)], 512);\n}, B.__file = \"src/components/va-affix/VaAffix.vue\";\nvar y = e(B);\nexport { y as default };","map":{"version":3,"mappings":"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","names":["noop","debounce","require$$0","isObject","require$$1","throttle_1","throttle","func","wait","options","leading","trailing","TypeError","maxWait","getWindowHeight","document","documentElement","clientHeight","window","innerHeight","body","computeAffixedState","coordinates","offsetTop","offsetBottom","target","isTopAffixed","isBottomAffixed","windowHeight","top","getBoundingClientRect","bottom","handleThrottledEvent","eventName","context","element","setState","getState","initialPosition","nextState","isInitialCall","prevState","checkAffixedStateChange","currentState","width","useCaptureDefault","defineComponent","name","emits","props","type","Number","default","undefined","Function","setup","emit","getTargetElement","isAffixed","computed","state","value","ref","newState","calculateTop","Window","calculateBottom","borderTopWidth","borderBottomWidth","getComputedStyle","offsetHeight","scrollBarHeight","parseInt","convertToPixels","calculate","result","computedClass","computedStyle","throttledEventHandler","event","clearEventListeners","onBeforeUnmount","onMounted","useEventsHandlerWithThrottle","events","handler","useCapture","clearHandlersArray","map","_handler","addEventListener","removeEventListener","forEach","clear","nextTick","class","x","_createElementBlock","_createElementVNode","style","_ctx","_renderSlot","_hoisted_1","s","withConfigTransport","VaAffix"],"sources":["../../../../node_modules/lodash/noop.js","../../../../node_modules/lodash/throttle.js","../../src/components/va-affix/VaAffix-utils.ts","../../src/components/va-affix/VaAffix.vue","../../src/components/va-affix/VaAffix.vue?vue&type=template&id=c9e05218&lang.js","../../src/components/va-affix/index.ts"],"sourcesContent":["/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","import throttle from 'lodash/throttle'\nimport { Vue } from 'vue-class-component'\n\nexport type State = {\n  isTopAffixed: boolean;\n  isBottomAffixed: boolean;\n  width?: number;\n}\n\ntype Coordinates = {\n  top: number;\n  bottom: number;\n}\n\ntype ValuesToComputeAffixedState = {\n  coordinates: Coordinates;\n  offsetTop?: number;\n  offsetBottom?: number;\n  target: HTMLElement | Window | undefined;\n}\n\nexport function getWindowHeight () {\n  return document.documentElement.clientHeight ||\n    window.innerHeight ||\n    document.body.clientHeight\n}\n\nexport function computeAffixedState ({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target,\n}: ValuesToComputeAffixedState): State {\n  let isTopAffixed = false\n  let isBottomAffixed = false\n\n  const windowHeight = getWindowHeight()\n\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop\n    } else {\n      const { top } = (target as HTMLElement).getBoundingClientRect()\n      isTopAffixed = coordinates.top - top <= offsetTop\n    }\n  }\n\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom\n    } else {\n      const { bottom } = (target as HTMLElement).getBoundingClientRect()\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom\n    }\n  }\n\n  return {\n    isTopAffixed,\n    isBottomAffixed,\n  }\n}\n\nfunction checkAffixedStateChange (currentState: State, nextState: State): boolean {\n  return currentState.isTopAffixed !== nextState.isTopAffixed ||\n    currentState.isBottomAffixed !== nextState.isBottomAffixed\n}\n\nexport type Context = {\n  offsetTop?: number;\n  offsetBottom?: number;\n  element: Vue | Element | Vue[] | Element[];\n  target: HTMLElement | Window | undefined;\n  setState: (state: State) => void;\n  getState: () => State;\n  initialPosition?: ClientRect;\n}\n\nexport function handleThrottledEvent (eventName: string | null, context: Context) {\n  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context\n\n  let nextState\n\n  const isInitialCall = !eventName\n\n  // Fixme: getBoundingClientRect should always exist on element\n  const coordinates = (element as HTMLElement).getBoundingClientRect()\n\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target,\n  }\n\n  if (isInitialCall && initialPosition) {\n    nextState = computeAffixedState({ coordinates: initialPosition, ...options })\n  } else {\n    nextState = computeAffixedState({ coordinates, ...options })\n  }\n\n  const prevState = getState()\n\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({ ...nextState, width: coordinates.width })\n  } else if (prevState.width !== coordinates.width) {\n    setState({ ...prevState, width: coordinates.width })\n  }\n}\n\nfunction useCaptureDefault (eventName: string) {\n  // This event type must bubble to the Window object only when dispatched on the Document element\n  // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll\n  return eventName === 'scroll'\n}\n\ntype Options = {\n  handler: (eventName: string, event: Event) => void;\n  useCapture?: (eventName: string) => boolean;\n  wait?: number;\n}\n\nexport function useEventsHandlerWithThrottle (events: string[], {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50,\n}: Options) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle((event: Event) => handler(eventName, event), wait)\n\n    window.addEventListener(eventName, _handler, useCapture(eventName))\n\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName))\n  })\n\n  return () => clearHandlersArray.forEach(clear => clear())\n}\n","<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent, computed, PropType, ref, Ref, nextTick, onMounted, onBeforeUnmount } from 'vue'\nimport noop from 'lodash/noop'\n\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State,\n  Context,\n} from './VaAffix-utils'\n\nexport default defineComponent({\n  name: 'VaAffix',\n  emits: ['change'],\n  props: {\n    offsetTop: { type: Number as PropType<number>, default: undefined },\n    offsetBottom: { type: Number as PropType<number>, default: undefined },\n    target: { type: Function as PropType<() => HTMLElement | Window>, default: () => () => window },\n  },\n  setup (props, { emit }) {\n    const getTargetElement = () => props.target()\n\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed)\n\n    const state: Ref<State> = ref({\n      isTopAffixed: false,\n      isBottomAffixed: false,\n    })\n    const getState = () => state.value\n    const setState = (newState: State) => {\n      state.value = newState\n      emit('change', isAffixed)\n    }\n\n    const calculateTop = () => {\n      const target = getTargetElement()\n\n      if (props.offsetTop === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { top } = target.getBoundingClientRect()\n        return top + props.offsetTop\n      }\n\n      return props.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = getTargetElement()\n\n      if (props.offsetBottom === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { bottom } = target.getBoundingClientRect()\n        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target)\n        const { offsetHeight, clientHeight } = target\n\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth)\n\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight\n      }\n\n      return props.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n      return result === undefined ? undefined : `${result}px`\n    }\n\n    const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }])\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,\n      width: `${state.value.width}px`,\n    }),\n    )\n\n    const initialPosition: Ref<undefined | DOMRect> = ref()\n    const element: Ref<HTMLElement | null> = ref(null)\n    const throttledEventHandler = (eventName: string | null, event?: Event) => {\n      const context: Context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value!,\n        target: getTargetElement(),\n        setState,\n        getState,\n      }\n\n      if (!eventName || eventName === 'resize') {\n        handleThrottledEvent(eventName, context)\n      } else if (event && event.target) {\n        const target = getTargetElement()\n\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context)\n        } else {\n          // if we have a custom target but keep scrolling on another element,\n          // so just disable the affixed state\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false,\n          })\n        }\n      }\n    }\n\n    let clearEventListeners: () => any = noop\n    onBeforeUnmount(() => clearEventListeners())\n    onMounted(() => {\n      const events = ['scroll', 'resize']\n\n      initialPosition.value = element.value?.getBoundingClientRect()\n\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler,\n      })\n\n      nextTick(() => {\n        // pass `null` here to make sure it is an initial call\n        throttledEventHandler(null)\n      })\n    })\n\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-affix {\n  font-family: var(--va-font-family);\n\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-z-index);\n  }\n}\n</style>\n","<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent, computed, PropType, ref, Ref, nextTick, onMounted, onBeforeUnmount } from 'vue'\nimport noop from 'lodash/noop'\n\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State,\n  Context,\n} from './VaAffix-utils'\n\nexport default defineComponent({\n  name: 'VaAffix',\n  emits: ['change'],\n  props: {\n    offsetTop: { type: Number as PropType<number>, default: undefined },\n    offsetBottom: { type: Number as PropType<number>, default: undefined },\n    target: { type: Function as PropType<() => HTMLElement | Window>, default: () => () => window },\n  },\n  setup (props, { emit }) {\n    const getTargetElement = () => props.target()\n\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed)\n\n    const state: Ref<State> = ref({\n      isTopAffixed: false,\n      isBottomAffixed: false,\n    })\n    const getState = () => state.value\n    const setState = (newState: State) => {\n      state.value = newState\n      emit('change', isAffixed)\n    }\n\n    const calculateTop = () => {\n      const target = getTargetElement()\n\n      if (props.offsetTop === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { top } = target.getBoundingClientRect()\n        return top + props.offsetTop\n      }\n\n      return props.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = getTargetElement()\n\n      if (props.offsetBottom === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { bottom } = target.getBoundingClientRect()\n        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target)\n        const { offsetHeight, clientHeight } = target\n\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth)\n\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight\n      }\n\n      return props.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n      return result === undefined ? undefined : `${result}px`\n    }\n\n    const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }])\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,\n      width: `${state.value.width}px`,\n    }),\n    )\n\n    const initialPosition: Ref<undefined | DOMRect> = ref()\n    const element: Ref<HTMLElement | null> = ref(null)\n    const throttledEventHandler = (eventName: string | null, event?: Event) => {\n      const context: Context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value!,\n        target: getTargetElement(),\n        setState,\n        getState,\n      }\n\n      if (!eventName || eventName === 'resize') {\n        handleThrottledEvent(eventName, context)\n      } else if (event && event.target) {\n        const target = getTargetElement()\n\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context)\n        } else {\n          // if we have a custom target but keep scrolling on another element,\n          // so just disable the affixed state\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false,\n          })\n        }\n      }\n    }\n\n    let clearEventListeners: () => any = noop\n    onBeforeUnmount(() => clearEventListeners())\n    onMounted(() => {\n      const events = ['scroll', 'resize']\n\n      initialPosition.value = element.value?.getBoundingClientRect()\n\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler,\n      })\n\n      nextTick(() => {\n        // pass `null` here to make sure it is an initial call\n        throttledEventHandler(null)\n      })\n    })\n\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-affix {\n  font-family: var(--va-font-family);\n\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-z-index);\n  }\n}\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport VaAffix from './VaAffix.vue'\n\nexport default withConfigTransport(VaAffix)\n"]},"metadata":{},"sourceType":"module"}